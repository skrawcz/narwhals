{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Narwhals","text":"<p>Extremely lightweight compatibility layer between Polars, pandas, and more.</p> <p>Seamlessly support both, without depending on either!</p> <ul> <li>\u2705 Just use a subset of the Polars API, no need to learn anything new</li> <li>\u2705 Zero dependencies, zero 3rd-party imports: Narwhals only uses what   the user passes in, so you can keep your library lightweight</li> <li>\u2705 Separate lazy and eager APIs, use expressions</li> <li>\u2705 Support pandas' complicated type system and index, without   either getting in the way</li> <li>\u2705 100% branch coverage, tested against pandas and Polars nightly builds</li> <li>\u2705 Negligible overhead, see overhead</li> </ul>"},{"location":"#whos-this-for","title":"Who's this for?","text":"<p>Anyone wishing to write a library/application/service which consumes dataframes, and wishing to make it completely dataframe-agnostic.</p> <p>Let's get started!</p>"},{"location":"extending/","title":"List of supported libraries (and how to add yours!)","text":"<p>Currently, Narwhals supports the following libraries as inputs:</p> <ul> <li>pandas</li> <li>Polars</li> <li>cuDF</li> <li>Modin</li> </ul> <p>If you want your own library to be recognised too, you're welcome open a PR (with tests)! Alternatively, if you can't do that (for example, if you library is closed-source), see the next section for what else you can do.</p>"},{"location":"extending/#extending-narwhals","title":"Extending Narwhals","text":"<p>We love open source, but we're not \"open source absolutists\". If you're unable to open source you library, then this is how you can make your library compatible with Narwhals.</p> <p>Make sure that, in addition to the public Narwhals API, you also define:</p> <ul> <li><code>DataFrame.__narwhals_dataframe__</code>: return an object which implements public methods     from <code>Narwhals.DataFrame</code></li> <li><code>DataFrame.__narwhals_namespace__</code>: return an object which implements public top-level     functions from <code>narwhals</code> (e.g. <code>narwhals.col</code>, <code>narwhals.concat</code>, ...)</li> <li><code>LazyFrame.__narwhals_lazyframe__</code>: return an object which implements public methods     from <code>Narwhals.LazyFrame</code></li> <li><code>LazyFrame.__narwhals_namespace__</code>: return an object which implements public top-level     functions from <code>narwhals</code> (e.g. <code>narwhals.col</code>, <code>narwhals.concat</code>, ...)</li> <li><code>Series.__narwhals_series__</code>: return an object which implements public methods     from <code>Narwhals.Series</code></li> <li><code>Series.__narwhals_namespace__</code>: return an object which implements public top-level     functions from <code>narwhals</code> (e.g. <code>narwhals.col</code>, <code>narwhals.concat</code>, ...)</li> </ul> <p>If your library doesn't distinguish between lazy and eager, then it's OK for your dataframe   object to implement both <code>__narwhals_dataframe__</code> and <code>__narwhals_lazyframe__</code>. In fact,   that's currently what <code>narwhals._pandas_like.dataframe.PandasDataFrame</code> does. So, if you're stuck,   take a look at the source code to see how it's done!</p> <p>Note that the \"extension\" mechanism is still experimental. If anything is not clear, or doesn't work, please do raise an issue or contact us on Discord (see the link on the README).</p>"},{"location":"how_it_works/","title":"How it works","text":""},{"location":"how_it_works/#theory","title":"Theory","text":"<p>You might think that Narwhals runs on underwater unicorn magic. However, this section exists to reassure you that there's no such thing. There's only one rule you need to understand in order to make sense of Narwhals:</p> <p>An expression is a function from a DataFrame to a sequence of Series.</p> <p>For example, <code>nw.col('a')</code> means \"given a dataframe <code>df</code>, give me the Series <code>'a'</code> from <code>df</code>\". Translating this to pandas syntax, we get:</p> <pre><code>def col_a(df):\n    return [df.loc[:, 'a']]\n</code></pre> <p>Let's step up the complexity. How about <code>nw.col('a')+1</code>? We already know what the <code>nw.col('a')</code> part looks like, so we just need to add <code>1</code> to each of its outputs:</p> <pre><code>def col_a(df):\n    return [df.loc[:, 'a']]\n\ndef col_a_plus_1(df):\n    return [x+1 for x in col_a(df)]\n</code></pre> <p>Expressions can return multiple Series - for example, <code>nw.col('a', 'b')</code> translates to:</p> <pre><code>def col_a_b(df):\n    return [df.loc[:, 'a'], df.loc[:, 'b']]\n</code></pre> <p>Expressions can also take multiple columns as input - for example, <code>nw.sum_horizontal('a', 'b')</code> translates to:</p> <pre><code>def sum_horizontal_a_b(df):\n    return [df.loc[:, 'a'] + df.loc[:, 'b']]\n</code></pre> <p>Note that although an expression may have multiple columns as input, those columns must all have been derived from the same dataframe. This last sentence was quite important, you might want to re-read it to make sure it sunk in.</p> <p>By itself, an expression doesn't produce a value. It only produces a value once you give it to a DataFrame context. What happens to the value(s) it produces depends on which context you hand it to:</p> <ul> <li><code>DataFrame.select</code>: produce a DataFrame with only the result of the given expression</li> <li><code>DataFrame.with_columns</code>: produce a DataFrame like the current one, but also with the result of   the given expression</li> <li><code>DataFrame.filter</code>: evaluate the given expression, and if it only returns a single Series, then   only keep rows where the result is <code>True</code>.</li> </ul> <p>Now let's turn our attention to the implementation.</p>"},{"location":"how_it_works/#polars-implementation","title":"Polars implementation","text":"<p>For Polars, Narwhals just \"passes everything through\". For example consider the following: <pre><code>import polars as pl\nimport narwhals as nw\n\ndf_pl = pl.DataFrame({'a': [1,2,3], 'b': [4,5,6]})\ndf = nw.from_native(df_pl)\ndf.select(nw.col('a')+1)\n</code></pre></p> <p><code>nw.col('a')</code> produces a <code>narwhals.expression.Expr</code> object, which has a private <code>_call</code> method. Inside <code>DataFrame.select</code>, we call <code>nw.col('a')._call(pl)</code>, which produces <code>pl.col('a')</code>.</p> <p>We then let Polars do its thing. Which is nice, but also not particularly interesting. How about translating expressions to pandas? Well, it's interesting to us, and you're still reading, so maybe it'll be interesting to you too.</p>"},{"location":"how_it_works/#pandas-implementation","title":"pandas implementation","text":"<p>When we called <code>nw.col('a')._call(pl)</code>, we got a Narwhals-compliant Polars namespace. The pandas namespace (<code>pd</code>) isn't Narwhals-compliant, as the pandas API is very different from Polars'. So...Narwhals implements a <code>PandasNamespace</code>, which includes the top-level Polars functions included in the Narwhals API:</p> <p><pre><code>import narwhals as nw\nfrom narwhals._pandas_like.namespace import PandasNamespace\n\npn = PandasNamespace(implementation='pandas')\nnw.col('a')._call(pn)\n</code></pre> The result from the last line above is the same as we'd get from <code>pn.col('a')</code>, and it's a <code>narwhals._pandas_like.expression.PandasExpr</code> object, which we'll call <code>PandasExpr</code> for short.</p> <p><code>PandasExpr</code> also has a <code>_call</code> method - but this one expects a <code>PandasDataFrame</code> as input. Recall from above that an expression is a function from a dataframe to a sequence of series. The <code>_call</code> method gives us that function! Let's see it in action.</p> <p>Note: the following examples use <code>PandasDataFrame</code> and <code>PandasSeries</code>. These are backed by actual <code>pandas.DataFrame</code>s and <code>pandas.Series</code> respectively and are Narwhals-compliant. We can access the  underlying pandas objects via <code>PandasDataFrame._dataframe</code> and <code>PandasSeries._series</code>.</p> <p><pre><code>import narwhals as nw\nfrom narwhals._pandas_like.namespace import PandasNamespace\nfrom narwhals._pandas_like.dataframe import PandasDataFrame\nimport pandas as pd\n\npn = PandasNamespace(implementation='pandas')\n\ndf_pd = pd.DataFrame({'a': [1,2,3], 'b': [4,5,6]})\ndf = PandasDataFrame(df_pd, implementation='pandas')\nexpression = pn.col('a') + 1\nresult = expression._call(df)\nprint([x._series for x in result])\n</code></pre> The first (and only) Series to be output is: <pre><code>0    2\n1    3\n2    4\nName: a, dtype: int64\n</code></pre></p> <p>So indeed, our expression did what it said on the tin - it took some dataframe, took column 'a', and added 1 to it.</p> <p>If you search for <code>def reuse_series_implementation</code>, you'll see that that's all expressions do in Narwhals - they just keep rigorously applying the definition of expression.</p> <p>It may look like there should be significant overhead to doing it this way - but really, it's just a few Python calls which get unwinded. From timing tests I've done, there's no detectable difference - in fact, because the Narwhals API guards against misusing the pandas API, it's likely that running pandas via Narwhals will in general be more efficient than running pandas directly.</p> <p>Further attempts at demistifying Narwhals, refactoring code so it's clearer, and explaining this section better are 110% welcome.</p>"},{"location":"how_it_works/#group-by","title":"Group-by","text":"<p>Group-by is probably one of Polars' most significant innovations (on the syntax side) with respect to pandas. We can write something like <pre><code>df: pl.DataFrame\ndf.group_by('a').agg((pl.col('c') &gt; pl.col('b').mean()).max())\n</code></pre> To do this in pandas, we need to either use <code>GroupBy.apply</code> (sloooow), or do some crazy manual optimisations to get it to work.</p> <p>In Narwhals, here's what we do:</p> <ul> <li>if somebody uses a simple group-by aggregation (e.g. <code>df.group_by('a').agg(nw.col('b').mean())</code>),   then on the pandas side we translate it to   <pre><code>df: pd.DataFrame\ndf.groupby('a').agg({'b': ['mean']})\n</code></pre></li> <li>if somebody passes a complex group-by aggregation, then we use <code>apply</code> and raise a <code>UserWarning</code>, warning   users of the performance penalty and advising them to refactor their code so that the aggregation they perform   ends up being a simple one.</li> </ul> <p>In order to tell whether an aggregation is simple, Narwhals uses the private <code>_depth</code> attribute of <code>PandasExpr</code>:</p> <pre><code>&gt;&gt;&gt; pn.col('a').mean()\nPandasExpr(depth=1, function_name=col-&gt;mean, root_names=['a'], output_names=['a']\n&gt;&gt;&gt; (pn.col('a')+1).mean()\nPandasExpr(depth=2, function_name=col-&gt;__add__-&gt;mean, root_names=['a'], output_names=['a']\n&gt;&gt;&gt; pn.mean('a')\nPandasExpr(depth=1, function_name=col-&gt;mean, root_names=['a'], output_names=['a']\n</code></pre> <p>For simple aggregations, Narwhals can just look at <code>_depth</code> and <code>function_name</code> and figure out which (efficient) elementary operation this corresponds to in pandas.</p>"},{"location":"installation/","title":"Installation","text":"<p>First, make sure you have created and activated a Python3.8+ virtual environment.</p> <p>Then, run <pre><code>python -m pip install narwhals\n</code></pre></p> <p>Then, if you start the Python REPL and see the following: <pre><code>&gt;&gt;&gt; import narwhals\n&gt;&gt;&gt; narwhals.__version__\n'0.9.17'\n</code></pre> then installation worked correctly!</p>"},{"location":"overhead/","title":"Overhead","text":"<p>Narwhals converts Polars syntax to non-Polars dataframes.</p> <p>So, what's the overhead of running pandas vs pandas via Narwhals?</p> <p>Based on experiments we've done, the answer is: it's negligible. Here are timings from the TPC-H queries, comparing running pandas directly vs running pandas via Narwhals:</p> <p></p> <p>Here's the code to reproduce the plot above, check the input sources for notebooks which run each individual query, along with the data sources.</p> <p>On some runs, the Narwhals code makes things marginally faster, on others marginally slower. The overall picture is clear: with Narwhals, you can support both Polars and pandas APIs with little to no impact on either.</p>"},{"location":"quick_start/","title":"Quick start","text":""},{"location":"quick_start/#prerequisites","title":"Prerequisites","text":"<p>Please start by following the installation instructions.</p> <p>To follow along with the examples which follow, please install the following (though note that they are not required dependencies - Narwhals only ever uses what the user passes in):</p> <ul> <li>pandas</li> <li>Polars</li> </ul>"},{"location":"quick_start/#simple-example","title":"Simple example","text":"<p>Create a Python file <code>t.py</code> with the following content:</p> <pre><code>import pandas as pd\nimport polars as pl\nimport narwhals as nw\n\n\ndef my_function(df_any):\n    df = nw.from_native(df_any)\n    column_names = df.columns\n    return column_names\n\n\ndf_pandas = pd.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 6]})\ndf_polars = pl.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 6]})\n\nprint('pandas output')\nprint(my_function(df_pandas))\nprint('Polars output')\nprint(my_function(df_polars))\n</code></pre> <pre><code>pandas output\n['a', 'b']\nPolars output\n['a', 'b']\n</code></pre> <p>If you run <code>python t.py</code> then your output should look like the above. This is the simplest possible example of a dataframe-agnostic function - as we'll soon see, we can do much more advanced things. Let's learn about what you just did, and what Narwhals can do for you!</p> <p>Note: these examples are only using pandas and Polars. Please see the following to find the supported libriaries.</p>"},{"location":"related/","title":"Related projects","text":""},{"location":"related/#dataframe-interchange-protocol","title":"Dataframe Interchange Protocol","text":"<p>Standardised way of interchanging data between libraries, see here.</p>"},{"location":"related/#dataframe-api-standard","title":"DataFrame API Standard","text":"<p>Now-discontinued project which aimed to \"provide a standard interface that encapsulates implementation details of dataframe libraries. This will allow users and third-party libraries to write code that interacts and operates with a standard dataframe, and not with specific implementations.\", see here.</p> <p>The Narwhals author was originally involved, but left due to irreconcilable differences in vision.</p> <p>Some notable difference are:</p> <ul> <li>Narwhals just uses a subset of the Polars API, whereas the dataframe standard introduces a new API</li> <li>Narwhals supports expressions, and separates lazy and eager execution</li> <li>Narwhals is a standalone, independent project, whereas the dataframe standard aims to be upstreamed   and implemented by major dataframe libraries.</li> </ul>"},{"location":"related/#ibis","title":"Ibis","text":"<p>Presents itself as a dataframe standard, and dispatches to 20+ backends. Some differences with Narwhals are:</p> <ul> <li>Narwhals is aimed at library maintainers, Ibis more to end users</li> <li>Narwhals has zero required dependencies, whereas Ibis requires pandas and PyArrow. For users starting   from non-pandas environments, the difference in the relative size increase is ~1000x</li> <li>Narwhals only supports 4 backends, Ibis more than 20</li> <li>Narwhals is focused on fundamental dataframe operations, Ibis on SQL backends</li> <li>Narwhals has negligible overhead for dataframe backends, while   Ibis' overhead can be significant</li> </ul> <p>The projects are not in competition and have different goals.</p>"},{"location":"related/#array-api","title":"Array API","text":"<p>Array counterpart to the DataFrame API, see here.</p>"},{"location":"roadmap/","title":"Roadmap","text":"<p>Where do we go from here? What are the project's priorities? In no particular order:</p>"},{"location":"roadmap/#tests-and-docs-coverage","title":"Tests and docs coverage","text":"<p>Every method should have a good docstring with an example.</p> <p>CI should test across a variety of pandas and Polars versions. Currently we just test latest and minimum versions.</p>"},{"location":"roadmap/#api-coverage","title":"API coverage","text":"<p>Narwhals should be complete enough to be able to execute all 22 tpc-h queries. Currently, it can execute the first 7.</p>"},{"location":"roadmap/#other-backends","title":"Other backends?","text":"<p>Narwhals is extesible - can we make it as easy as possible for backends to become compatible with it?</p>"},{"location":"roadmap/#use-cases","title":"Use cases","text":"<p>Ideas for other projects where Narwhals might be useful? If so, please post them here.</p>"},{"location":"why/","title":"Why?","text":"<p>You may think that pandas, Polars, and all dataframe libraries are quite similar. But are they really?</p> <p>For example, do the following produce the same output?</p> <pre><code>import pandas as pd\nimport polars as pl\n\nprint(3 in pd.Series([1, 2, 3]))\nprint(3 in pl.Series([1, 2, 3]))\n</code></pre> <p>Try it out and see ;) Spoiler alert: they don't. pandas checks if <code>3</code> is in the index, Polars checks if it's in the values.</p> <p>How about <pre><code>df_left = pd.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 6]})\ndf_right = pd.DataFrame({'a': [1, 2, 3], 'c': [4, 5, 6]})\ndf_left.merge(df_right, left_on='b', right_on='c', how='left')\n</code></pre> versus</p> <pre><code>df_left = pl.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 6]})\ndf_right = pl.DataFrame({'a': [1, 2, 3], 'c': [4, 5, 6]})\ndf_left.join(df_right, left_on='b', right_on='c', how='left')\n</code></pre> <p>?</p> <p>There are several such subtle difference between the libraries. Writing dataframe-agnostic code is hard! But by having a unified, simple, and predictable API, you can focus on behaviour rather than on subtle implementation differences.</p> <p>Furthermore, both pandas and Polars frequently deprecate behaviour. Narwhals handles this for you by testing against nightly builds of both libraries and handling backwards compatibility internally  (so you don't have to!).</p>"},{"location":"api-reference/","title":"API Reference","text":"<p>Anything documented in the API reference is intended to work consistently among supported backends.</p> <p>For example: <pre><code>import narwhals as nw\n\ndf.with_columns(\n    a_mean = nw.col('a').mean(),\n    a_std = nw.col('a').std(),\n)\n</code></pre> is supported, as <code>DataFrame.with_columns</code>, <code>narwhals.col</code>, <code>Expr.mean</code>, and <code>Expr.std</code> are all documented in the API reference.</p> <p>However, <pre><code>import narwhals as nw\n\ndf.with_columns(\n    a_ewm_mean = nw.col('a').ewm_mean(alpha=.7),\n)\n</code></pre> is not - <code>Expr.ewm_mean</code> only appears in the Polars API reference, but not in the Narwhals one.</p> <p>In general, you should expect any fundamental dataframe operation to be supported - if one that you need is not, please do open a feature request!</p>"},{"location":"api-reference/dataframe/","title":"<code>narwhals.DataFrame</code>","text":"<p>Narwhals DataFrame, backed by a native dataframe.</p> <p>The native dataframe might be pandas.DataFrame, polars.DataFrame, ...</p> <p>This class is not meant to be instantiated directly - instead, use <code>narwhals.from_native</code>.</p>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.columns","title":"<code>columns: list[str]</code>  <code>property</code>","text":"<p>Get column names.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0], \"ham\": [\"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     return df.columns\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n['foo', 'bar', 'ham']\n&gt;&gt;&gt; func(df_pl)\n['foo', 'bar', 'ham']\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.schema","title":"<code>schema: dict[str, DType]</code>  <code>property</code>","text":"<p>Get a dict[column name, DataType].</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"foo\": [1, 2, 3],\n...     \"bar\": [6.0, 7.0, 8.0],\n...     \"ham\": [\"a\", \"b\", \"c\"],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     return df.schema\n</code></pre> <p>You can pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; df_pd_schema = func(df_pd)\n&gt;&gt;&gt; df_pd_schema\n{'foo': Int64, 'bar': Float64, 'ham': String}\n</code></pre> <pre><code>&gt;&gt;&gt; df_pl_schema = func(df_pl)\n&gt;&gt;&gt; df_pl_schema\n{'foo': Int64, 'bar': Float64, 'ham': String}\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.shape","title":"<code>shape: tuple[int, int]</code>  <code>property</code>","text":"<p>Get the shape of the DataFrame.</p> <p>Examples:</p> <p>Construct pandas and polars DataFrames:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\"foo\": [1, 2, 3, 4, 5]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     return df.shape\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n(5, 1)\n&gt;&gt;&gt; func(df_pl)\n(5, 1)\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.drop","title":"<code>drop(*columns)</code>","text":"<p>Remove columns from the dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>*columns</code> <code>str | Iterable[str]</code> <p>Names of the columns that should be removed from the dataframe.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0], \"ham\": [\"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     df = df.drop(\"ham\")\n...     return nw.to_native(df)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo  bar\n0    1  6.0\n1    2  7.0\n2    3  8.0\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6.0 \u2502\n\u2502 2   \u2506 7.0 \u2502\n\u2502 3   \u2506 8.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.drop_nulls","title":"<code>drop_nulls()</code>","text":"<p>Drop null values.</p> Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [1.0, 2.0, None], \"ba\": [1, None, 2.0]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     df = df.drop_nulls()\n...     return nw.to_native(df)\n</code></pre> <p>We can then pass either pandas or Polars:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n     a   ba\n0  1.0  1.0\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 ba  \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 f64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0 \u2506 1.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.filter","title":"<code>filter(*predicates)</code>","text":"<p>Filter the rows in the DataFrame based on one or more predicate expressions.</p> <p>The original order of the remaining rows is preserved.</p> <p>Parameters:</p> Name Type Description Default <code>predicates</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Expression(s) that evaluates to a boolean Series.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\n...     \"foo\": [1, 2, 3],\n...     \"bar\": [6, 7, 8],\n...     \"ham\": [\"a\", \"b\", \"c\"],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>Let's define a dataframe-agnostic function in which we filter on one condition.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.filter(nw.col(\"foo\") &gt; 1)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n1    2    7   b\n2    3    8   c\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2506 7   \u2506 b   \u2502\n\u2502 3   \u2506 8   \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Filter on multiple conditions, combined with and/or operators:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.filter((nw.col(\"foo\") &lt; 3) &amp; (nw.col(\"ham\") == \"a\"))\n&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n0    1    6   a\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2506 a   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.filter((nw.col(\"foo\") == 1) | (nw.col(\"ham\") == \"c\"))\n&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n0    1    6   a\n2    3    8   c\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2506 a   \u2502\n\u2502 3   \u2506 8   \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Provide multiple filters using <code>*args</code> syntax:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     dframe = df.filter(\n...         nw.col(\"foo\") &lt;= 2,\n...         ~nw.col(\"ham\").is_in([\"b\", \"c\"]),\n...     )\n...     return dframe\n&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n0    1    6   a\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2506 a   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.group_by","title":"<code>group_by(*keys)</code>","text":"<p>Start a group by operation.</p> <p>Parameters:</p> Name Type Description Default <code>*keys</code> <code>str | Iterable[str]</code> <p>Column(s) to group by. Accepts multiple columns names as a list.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>GroupBy</code> <code>GroupBy</code> <p>Object which can be used to perform aggregations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\n...     \"a\": [\"a\", \"b\", \"a\", \"b\", \"c\"],\n...     \"b\": [1, 2, 1, 3, 3],\n...     \"c\": [5, 4, 3, 2, 1],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>Let's define a dataframe-agnostic function in which we group by one column and call <code>agg</code> to compute the grouped sum of another column.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.group_by(\"a\").agg(nw.col(\"b\").sum()).sort(\"a\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n0  a  2\n1  b  5\n2  c  3\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 2   \u2502\n\u2502 b   \u2506 5   \u2502\n\u2502 c   \u2506 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Group by multiple columns by passing a list of column names.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.group_by([\"a\", \"b\"]).agg(nw.max(\"c\")).sort(\"a\", \"b\")\n&gt;&gt;&gt; func(df_pd)\n   a  b  c\n0  a  1  5\n1  b  2  4\n2  b  3  2\n3  c  3  1\n&gt;&gt;&gt; func(df_pl)\nshape: (4, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1   \u2506 5   \u2502\n\u2502 b   \u2506 2   \u2506 4   \u2502\n\u2502 b   \u2506 3   \u2506 2   \u2502\n\u2502 c   \u2506 3   \u2506 1   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.head","title":"<code>head(n=5)</code>","text":"<p>Get the first <code>n</code> rows.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of rows to return. If a negative value is passed, return all rows except the last <code>abs(n)</code>.</p> <code>5</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\n...     \"foo\": [1, 2, 3, 4, 5],\n...     \"bar\": [6, 7, 8, 9, 10],\n...     \"ham\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>Let's define a dataframe-agnostic function that gets the first 3 rows.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.head(3)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n0    1    6   a\n1    2    7   b\n2    3    8   c\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2506 a   \u2502\n\u2502 2   \u2506 7   \u2506 b   \u2502\n\u2502 3   \u2506 8   \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.is_duplicated","title":"<code>is_duplicated()</code>","text":"<p>Get a mask of all duplicated rows in this DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; df_pd = pd.DataFrame(\n...     {\n...         \"a\": [1, 2, 3, 1],\n...         \"b\": [\"x\", \"y\", \"z\", \"x\"],\n...     }\n... )\n&gt;&gt;&gt; df_pl = pl.DataFrame(\n...     {\n...         \"a\": [1, 2, 3, 1],\n...         \"b\": [\"x\", \"y\", \"z\", \"x\"],\n...     }\n... )\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     duplicated = df.is_duplicated()\n...     return nw.to_native(duplicated)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n0     True\n1    False\n2    False\n3     True\ndtype: bool\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (4,)\nSeries: '' [bool]\n[\n    true\n    false\n    false\n    true\n]\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.is_empty","title":"<code>is_empty()</code>","text":"<p>Check if the dataframe is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n</code></pre> <p>Let's define a dataframe-agnostic function that filters rows in which \"foo\" values are greater than 10, and then checks if the result is empty or not:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     return df.filter(nw.col(\"foo\") &gt; 10).is_empty()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; df_pd = pd.DataFrame({\"foo\": [1, 2, 3], \"bar\": [4, 5, 6]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"foo\": [1, 2, 3], \"bar\": [4, 5, 6]})\n&gt;&gt;&gt; func(df_pd), func(df_pl)\n(True, True)\n</code></pre> <pre><code>&gt;&gt;&gt; df_pd = pd.DataFrame({\"foo\": [100, 2, 3], \"bar\": [4, 5, 6]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"foo\": [100, 2, 3], \"bar\": [4, 5, 6]})\n&gt;&gt;&gt; func(df_pd), func(df_pl)\n(False, False)\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.is_unique","title":"<code>is_unique()</code>","text":"<p>Get a mask of all unique rows in this DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; df_pd = pd.DataFrame(\n...     {\n...         \"a\": [1, 2, 3, 1],\n...         \"b\": [\"x\", \"y\", \"z\", \"x\"],\n...     }\n... )\n&gt;&gt;&gt; df_pl = pl.DataFrame(\n...     {\n...         \"a\": [1, 2, 3, 1],\n...         \"b\": [\"x\", \"y\", \"z\", \"x\"],\n...     }\n... )\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     unique = df.is_unique()\n...     return nw.to_native(unique)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n0    False\n1     True\n2     True\n3    False\ndtype: bool\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (4,)\nSeries: '' [bool]\n[\n    false\n     true\n     true\n    false\n]\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.item","title":"<code>item(row=None, column=None)</code>","text":"<p>Return the DataFrame as a scalar, or return the element at the given row/column.</p> Notes <p>If row/col not provided, this is equivalent to df[0,0], with a check that the shape is (1,1). With row/col, this is equivalent to df[row,col].</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3], \"b\": [4, 5, 6]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function that returns item at given row/column</p> <pre><code>&gt;&gt;&gt; def func(df_any, row, column):\n...     df = nw.from_native(df_any)\n...     return df.item(row, column)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd, 1, 1), func(df_pd, 2, \"b\")\n(5, 6)\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl, 1, 1), func(df_pl, 2, \"b\")\n(5, 6)\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.iter_rows","title":"<code>iter_rows(*, named=False, buffer_size=512)</code>","text":"<p>Returns an iterator over the DataFrame of rows of python-native values.</p> <p>Parameters:</p> Name Type Description Default <code>named</code> <code>bool</code> <p>By default, each row is returned as a tuple of values given in the same order as the frame columns. Setting named=True will return rows of dictionaries instead.</p> <code>False</code> <code>buffer_size</code> <code>int</code> <p>Determines the number of rows that are buffered internally while iterating over the data. See https://docs.pola.rs/api/python/stable/reference/dataframe/api/polars.DataFrame.iter_rows.html</p> <code>512</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0], \"ham\": [\"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; def func(df_any, *, named):\n...     df = nw.from_native(df_any)\n...     return df.iter_rows(named=named)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; [row for row in func(df_pd, named=False)]\n[(1, 6.0, 'a'), (2, 7.0, 'b'), (3, 8.0, 'c')]\n&gt;&gt;&gt; [row for row in func(df_pd, named=True)]\n[{'foo': 1, 'bar': 6.0, 'ham': 'a'}, {'foo': 2, 'bar': 7.0, 'ham': 'b'}, {'foo': 3, 'bar': 8.0, 'ham': 'c'}]\n&gt;&gt;&gt; [row for row in func(df_pl, named=False)]\n[(1, 6.0, 'a'), (2, 7.0, 'b'), (3, 8.0, 'c')]\n&gt;&gt;&gt; [row for row in func(df_pl, named=True)]\n[{'foo': 1, 'bar': 6.0, 'ham': 'a'}, {'foo': 2, 'bar': 7.0, 'ham': 'b'}, {'foo': 3, 'bar': 8.0, 'ham': 'c'}]\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.join","title":"<code>join(other, *, how='inner', left_on, right_on)</code>","text":"<p>Join in SQL-like fashion.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>DataFrame to join with.</p> required <code>how</code> <code>Literal['inner']</code> <p>{'inner'}   Join strategy.</p> <ul> <li>inner: Returns rows that have matching values in both               tables</li> </ul> <code>'inner'</code> <code>left_on</code> <code>str | list[str]</code> <p>Name(s) of the left join column(s).</p> required <code>right_on</code> <code>str | list[str]</code> <p>Name(s) of the right join column(s).</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A new joined DataFrame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pl = pl.DataFrame(\n...     {\n...         \"foo\": [1, 2, 3],\n...         \"bar\": [6.0, 7.0, 8.0],\n...         \"ham\": [\"a\", \"b\", \"c\"],\n...     }\n... )\n&gt;&gt;&gt; other_df_pl = pl.DataFrame(\n...     {\n...         \"apple\": [\"x\", \"y\", \"z\"],\n...         \"ham\": [\"a\", \"b\", \"d\"],\n...     }\n... )\n&gt;&gt;&gt; df = nw.DataFrame(df_pl)\n&gt;&gt;&gt; other_df = nw.DataFrame(other_df_pl)\n&gt;&gt;&gt; dframe = df.join(other_df, left_on=\"ham\", right_on=\"ham\")\n&gt;&gt;&gt; dframe\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame                            |\n| Use `narwhals.to_native` to see native output |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; nw.to_native(dframe)\nshape: (2, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2506 apple \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2506 ---   \u2502\n\u2502 i64 \u2506 f64 \u2506 str \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6.0 \u2506 a   \u2506 x     \u2502\n\u2502 2   \u2506 7.0 \u2506 b   \u2506 y     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.null_count","title":"<code>null_count()</code>","text":"<p>Create a new DataFrame that shows the null counts per column.</p> Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; df_pd = pd.DataFrame(\n...     {\n...         \"foo\": [1, None, 3],\n...         \"bar\": [6, 7, None],\n...         \"ham\": [\"a\", \"b\", \"c\"],\n...     }\n... )\n&gt;&gt;&gt; df_pl = pl.DataFrame(\n...     {\n...         \"foo\": [1, None, 3],\n...         \"bar\": [6, 7, None],\n...         \"ham\": [\"a\", \"b\", \"c\"],\n...     }\n... )\n</code></pre> <p>Let's define a dataframe-agnostic function that returns the null count of each columns:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     null_counts = df.null_count()\n...     return nw.to_native(null_counts)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo  bar  ham\n0    1    1    0\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 u32 \u2506 u32 \u2506 u32 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 1   \u2506 0   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.pipe","title":"<code>pipe(function, *args, **kwargs)</code>","text":"<p>Pipe function call.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3], \"ba\": [4, 5, 6]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     df = df.pipe(\n...         lambda _df: _df.select([x for x in _df.columns if len(x) == 1])\n...     )\n...     return nw.to_native(df)\n</code></pre> <p>We can then pass either pandas or Polars:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a\n0  1\n1  2\n2  3\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2502\n\u2502 2   \u2502\n\u2502 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.rename","title":"<code>rename(mapping)</code>","text":"<p>Rename column names.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>dict[str, str]</code> <p>Key value pairs that map from old name to new name.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\"foo\": [1, 2, 3], \"bar\": [6, 7, 8], \"ham\": [\"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.rename({\"foo\": \"apple\"})\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   apple  bar ham\n0      1    6   a\n1      2    7   b\n2      3    8   c\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 apple \u2506 bar \u2506 ham \u2502\n\u2502 ---   \u2506 --- \u2506 --- \u2502\n\u2502 i64   \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1     \u2506 6   \u2506 a   \u2502\n\u2502 2     \u2506 7   \u2506 b   \u2502\n\u2502 3     \u2506 8   \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.select","title":"<code>select(*exprs, **named_exprs)</code>","text":"<p>Select columns from this DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>*exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Column(s) to select, specified as positional arguments.      Accepts expression input. Strings are parsed as column names,      other non-expression inputs are parsed as literals.</p> <code>()</code> <code>**named_exprs</code> <code>IntoExpr</code> <p>Additional columns to select, specified as keyword arguments.             The columns will be renamed to the keyword used.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\n...     \"foo\": [1, 2, 3],\n...     \"bar\": [6, 7, 8],\n...     \"ham\": [\"a\", \"b\", \"c\"],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>Let's define a dataframe-agnostic function in which we pass the name of a column to select that column.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(\"foo\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo\n0    1\n1    2\n2    3\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2502\n\u2502 2   \u2502\n\u2502 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Multiple columns can be selected by passing a list of column names.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select([\"foo\", \"bar\"])\n&gt;&gt;&gt; func(df_pd)\n   foo  bar\n0    1    6\n1    2    7\n2    3    8\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2502\n\u2502 2   \u2506 7   \u2502\n\u2502 3   \u2506 8   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Multiple columns can also be selected using positional arguments instead of a list. Expressions are also accepted.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"foo\"), nw.col(\"bar\") + 1)\n&gt;&gt;&gt; func(df_pd)\n   foo  bar\n0    1    7\n1    2    8\n2    3    9\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 7   \u2502\n\u2502 2   \u2506 8   \u2502\n\u2502 3   \u2506 9   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Use keyword arguments to easily name your expression inputs.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(threshold=nw.col(\"foo\") * 2)\n&gt;&gt;&gt; func(df_pd)\n   threshold\n0          2\n1          4\n2          6\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 threshold \u2502\n\u2502 ---       \u2502\n\u2502 i64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2         \u2502\n\u2502 4         \u2502\n\u2502 6         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.sort","title":"<code>sort(by, *more_by, descending=False)</code>","text":"<p>Sort the dataframe by the given columns.</p> <p>Parameters:</p> Name Type Description Default <code>by</code> <code>str | Iterable[str]</code> <p>Column(s) names to sort by.</p> required <code>*more_by</code> <code>str</code> <p>Additional columns to sort by, specified as positional        arguments.</p> <code>()</code> <code>descending</code> <code>bool | Sequence[bool]</code> <p>Sort in descending order. When sorting by multiple          columns, can be specified per column by passing a          sequence of booleans.</p> <code>False</code> <p>Examples:</p> <p>Pass a single column name to sort by that column.</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pl = pl.DataFrame(\n...     {\n...         \"a\": [1, 2, None],\n...         \"b\": [6.0, 5.0, 4.0],\n...         \"c\": [\"a\", \"c\", \"b\"],\n...     }\n... )\n&gt;&gt;&gt; df = nw.DataFrame(df_pl)\n&gt;&gt;&gt; dframe = df.sort(\"a\")\n&gt;&gt;&gt; dframe\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame                            |\n| Use `narwhals.to_native` to see native output |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; nw.to_native(dframe)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b   \u2506 c   \u2502\n\u2502 ---  \u2506 --- \u2506 --- \u2502\n\u2502 i64  \u2506 f64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 null \u2506 4.0 \u2506 b   \u2502\n\u2502 1    \u2506 6.0 \u2506 a   \u2502\n\u2502 2    \u2506 5.0 \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Sort by multiple columns by passing a list of columns.</p> <pre><code>&gt;&gt;&gt; dframe = df.sort([\"c\", \"a\"], descending=True)\n&gt;&gt;&gt; dframe\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame                            |\n| Use `narwhals.to_native` to see native output |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; nw.to_native(dframe)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b   \u2506 c   \u2502\n\u2502 ---  \u2506 --- \u2506 --- \u2502\n\u2502 i64  \u2506 f64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2    \u2506 5.0 \u2506 c   \u2502\n\u2502 null \u2506 4.0 \u2506 b   \u2502\n\u2502 1    \u2506 6.0 \u2506 a   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Or use positional arguments to sort by multiple columns in the same way.</p> <pre><code>&gt;&gt;&gt; dframe = df.sort(\"c\", \"a\", descending=[False, True])\n&gt;&gt;&gt; dframe\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame                            |\n| Use `narwhals.to_native` to see native output |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; nw.to_native(dframe)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b   \u2506 c   \u2502\n\u2502 ---  \u2506 --- \u2506 --- \u2502\n\u2502 i64  \u2506 f64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 6.0 \u2506 a   \u2502\n\u2502 null \u2506 4.0 \u2506 b   \u2502\n\u2502 2    \u2506 5.0 \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.tail","title":"<code>tail(n=5)</code>","text":"<p>Get the last <code>n</code> rows.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of rows to return. If a negative value is passed, return all rows except the first <code>abs(n)</code>.</p> <code>5</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\n...     \"foo\": [1, 2, 3, 4, 5],\n...     \"bar\": [6, 7, 8, 9, 10],\n...     \"ham\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>Let's define a dataframe-agnostic function that gets the last 3 rows.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.tail(3)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n2    3    8   c\n3    4    9   d\n4    5   10   e\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 3   \u2506 8   \u2506 c   \u2502\n\u2502 4   \u2506 9   \u2506 d   \u2502\n\u2502 5   \u2506 10  \u2506 e   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.to_dict","title":"<code>to_dict(*, as_series=True)</code>","text":"<p>Convert DataFrame to a dictionary mapping column name to values.</p> <p>Parameters:</p> Name Type Description Default <code>as_series</code> <code>bool</code> <p>If set to true <code>True</code>, then the values are Narwhals Series,         otherwise the values are Any.</p> <code>True</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\n...     \"A\": [1, 2, 3, 4, 5],\n...     \"fruits\": [\"banana\", \"banana\", \"apple\", \"apple\", \"banana\"],\n...     \"B\": [5, 4, 3, 2, 1],\n...     \"cars\": [\"beetle\", \"audi\", \"beetle\", \"beetle\", \"beetle\"],\n...     \"optional\": [28, 300, None, 2, -30],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     df = df.to_dict(as_series=False)\n...     return df\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n{'A': [1, 2, 3, 4, 5], 'fruits': ['banana', 'banana', 'apple', 'apple', 'banana'], 'B': [5, 4, 3, 2, 1], 'cars': ['beetle', 'audi', 'beetle', 'beetle', 'beetle'], 'optional': [28.0, 300.0, nan, 2.0, -30.0]}\n&gt;&gt;&gt; func(df_pl)\n{'A': [1, 2, 3, 4, 5], 'fruits': ['banana', 'banana', 'apple', 'apple', 'banana'], 'B': [5, 4, 3, 2, 1], 'cars': ['beetle', 'audi', 'beetle', 'beetle', 'beetle'], 'optional': [28, 300, None, 2, -30]}\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.to_numpy","title":"<code>to_numpy()</code>","text":"<p>Convert this DataFrame to a NumPy ndarray.</p> <p>Examples:</p> <p>Construct pandas and polars DataFrames:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\"foo\": [1, 2, 3], \"bar\": [6.5, 7.0, 8.5], \"ham\": [\"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     df = df.to_numpy()\n...     return df\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\narray([[1, 6.5, 'a'],\n       [2, 7.0, 'b'],\n       [3, 8.5, 'c']], dtype=object)\n&gt;&gt;&gt; func(df_pl)\narray([[1, 6.5, 'a'],\n       [2, 7.0, 'b'],\n       [3, 8.5, 'c']], dtype=object)\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.to_pandas","title":"<code>to_pandas()</code>","text":"<p>Convert this DataFrame to a pandas DataFrame.</p> <p>Examples:</p> <p>Construct pandas and Polars DataFrames:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0], \"ham\": [\"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     df = df.to_pandas()\n...     return df\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n0    1  6.0   a\n1    2  7.0   b\n2    3  8.0   c\n&gt;&gt;&gt; func(df_pl)\n   foo  bar ham\n0    1  6.0   a\n1    2  7.0   b\n2    3  8.0   c\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.unique","title":"<code>unique(subset)</code>","text":"<p>Drop duplicate rows from this dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>subset</code> <code>str | list[str]</code> <p>Column name(s) to consider when identifying duplicate rows.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\n...     \"foo\": [1, 2, 3, 1],\n...     \"bar\": [\"a\", \"a\", \"a\", \"a\"],\n...     \"ham\": [\"b\", \"b\", \"b\", \"b\"],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     df = df.unique([\"bar\", \"ham\"])\n...     return nw.to_native(df)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo bar ham\n0    1   a   b\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 str \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 a   \u2506 b   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.with_columns","title":"<code>with_columns(*exprs, **named_exprs)</code>","text":"<p>Add columns to this DataFrame.</p> <p>Added columns will replace existing columns with the same name.</p> <p>Parameters:</p> Name Type Description Default <code>*exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Column(s) to add, specified as positional arguments.      Accepts expression input. Strings are parsed as column names, other      non-expression inputs are parsed as literals.</p> <code>()</code> <code>**named_exprs</code> <code>IntoExpr</code> <p>Additional columns to add, specified as keyword arguments.             The columns will be renamed to the keyword used.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>Self</code> <p>A new DataFrame with the columns added.</p> Note <p>Creating a new DataFrame using this method does not create a new copy of existing data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\n...     \"a\": [1, 2, 3, 4],\n...     \"b\": [0.5, 4, 10, 13],\n...     \"c\": [True, True, False, True],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>Let's define a dataframe-agnostic function in which we pass an expression to add it as a new column:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns((nw.col(\"a\") * 2).alias(\"a*2\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a     b      c  a*2\n0  1   0.5   True    2\n1  2   4.0   True    4\n2  3  10.0  False    6\n3  4  13.0   True    8\n&gt;&gt;&gt; func(df_pl)\nshape: (4, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b    \u2506 c     \u2506 a*2 \u2502\n\u2502 --- \u2506 ---  \u2506 ---   \u2506 --- \u2502\n\u2502 i64 \u2506 f64  \u2506 bool  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 0.5  \u2506 true  \u2506 2   \u2502\n\u2502 2   \u2506 4.0  \u2506 true  \u2506 4   \u2502\n\u2502 3   \u2506 10.0 \u2506 false \u2506 6   \u2502\n\u2502 4   \u2506 13.0 \u2506 true  \u2506 8   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.with_row_index","title":"<code>with_row_index(name='index')</code>","text":"<p>Insert column which enumerates rows.</p> <p>Examples:</p> <p>Construct pandas as polars DataFrames:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3], \"b\": [4, 5, 6]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     df = df.with_row_index()\n...     return nw.to_native(df)\n</code></pre> <p>We can then pass either pandas or Polars:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   index  a  b\n0      0  1  4\n1      1  2  5\n2      2  3  6\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 index \u2506 a   \u2506 b   \u2502\n\u2502 ---   \u2506 --- \u2506 --- \u2502\n\u2502 u32   \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0     \u2506 1   \u2506 4   \u2502\n\u2502 1     \u2506 2   \u2506 5   \u2502\n\u2502 2     \u2506 3   \u2506 6   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.write_parquet","title":"<code>write_parquet(file)</code>","text":"<p>Write dataframe to parquet file.</p> <p>Examples:</p> <p>Construct pandas and Polars DataFrames:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0], \"ham\": [\"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     df.write_parquet(\"foo.parquet\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n&gt;&gt;&gt; func(df_pl)\n</code></pre>"},{"location":"api-reference/dependencies/","title":"<code>narwhals.dependencies</code>","text":""},{"location":"api-reference/dependencies/#narwhals.dependencies.get_pandas","title":"<code>get_pandas()</code>","text":"<p>Get pandas module (if already imported - else return None).</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.get_polars","title":"<code>get_polars()</code>","text":"<p>Get Polars module (if already imported - else return None).</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.get_modin","title":"<code>get_modin()</code>","text":"<p>Get modin.pandas module (if already imported - else return None).</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.get_cudf","title":"<code>get_cudf()</code>","text":"<p>Get cudf module (if already imported - else return None).</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.get_pyarrow","title":"<code>get_pyarrow()</code>","text":"<p>Get pyarrow module (if already imported - else return None).</p>"},{"location":"api-reference/dtypes/","title":"<code>narwhals.dtypes</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Int64","title":"<code>Int64</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Int32","title":"<code>Int32</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Int16","title":"<code>Int16</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Int8","title":"<code>Int8</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.UInt64","title":"<code>UInt64</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.UInt32","title":"<code>UInt32</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.UInt16","title":"<code>UInt16</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.UInt8","title":"<code>UInt8</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Float64","title":"<code>Float64</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Float32","title":"<code>Float32</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Boolean","title":"<code>Boolean</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Categorical","title":"<code>Categorical</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.String","title":"<code>String</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Datetime","title":"<code>Datetime</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Object","title":"<code>Object</code>","text":""},{"location":"api-reference/expressions/","title":"<code>narwhals.Expr</code>","text":""},{"location":"api-reference/expressions/#narwhals.Expr.alias","title":"<code>alias(name)</code>","text":"<p>Rename the expression.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The new name.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2], \"b\": [4, 5]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2], \"b\": [4, 5]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df_any):\n...     return df_any.select((nw.col(\"b\") + 10).alias(\"c\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n    c\n0  14\n1  15\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 c   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 14  \u2502\n\u2502 15  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.all","title":"<code>all()</code>","text":"<p>Return whether all values in the column are <code>True</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [True, False], \"b\": [True, True]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [True, False], \"b\": [True, True]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\", \"b\").all())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n       a     b\n0  False  True\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a     \u2506 b    \u2502\n\u2502 ---   \u2506 ---  \u2502\n\u2502 bool  \u2506 bool \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 false \u2506 true \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.any","title":"<code>any()</code>","text":"<p>Return whether any of the values in the column are <code>True</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [True, False], \"b\": [True, True]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [True, False], \"b\": [True, True]})\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\", \"b\").any())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n      a     b\n0  True  True\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b    \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 bool \u2506 bool \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 true \u2506 true \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.cast","title":"<code>cast(dtype)</code>","text":"<p>Redefine an object's data type.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>Any</code> <p>Data type that the object will be cast into.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from datetime import date\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df_any):\n...     return df_any.select(\n...         nw.col(\"foo\").cast(nw.Float32), nw.col(\"bar\").cast(nw.UInt8)\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo  bar\n0  1.0    6\n1  2.0    7\n2  3.0    8\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 f32 \u2506 u8  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0 \u2506 6   \u2502\n\u2502 2.0 \u2506 7   \u2502\n\u2502 3.0 \u2506 8   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.cum_sum","title":"<code>cum_sum()</code>","text":"<p>Return cumulative sum.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 1, 3, 5, 5], \"b\": [2, 4, 4, 6, 6]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 1, 3, 5, 5], \"b\": [2, 4, 4, 6, 6]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\", \"b\").cum_sum())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n    a   b\n0   1   2\n1   2   6\n2   5  10\n3  10  16\n4  15  22\n&gt;&gt;&gt; func(df_pl)\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 2   \u2502\n\u2502 2   \u2506 6   \u2502\n\u2502 5   \u2506 10  \u2502\n\u2502 10  \u2506 16  \u2502\n\u2502 15  \u2506 22  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.diff","title":"<code>diff()</code>","text":"<p>Returns the difference between each element and the previous one.</p> Notes <p>pandas may change the dtype here, for example when introducing missing values in an integer column. To ensure, that the dtype doesn't change, you may want to use <code>fill_null</code> and <code>cast</code>. For example, to calculate the diff and fill missing values with <code>0</code> in a Int64 column, you could do:</p> <pre><code>nw.col(\"a\").diff().fill_null(0).cast(nw.Int64)\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 1, 3, 5, 5]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 1, 3, 5, 5]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(a_diff=nw.col(\"a\").diff())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a_diff\n0     NaN\n1     0.0\n2     2.0\n3     2.0\n4     0.0\n&gt;&gt;&gt; func(df_pl)\nshape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a_diff \u2502\n\u2502 ---    \u2502\n\u2502 i64    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 null   \u2502\n\u2502 0      \u2502\n\u2502 2      \u2502\n\u2502 2      \u2502\n\u2502 0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.drop_nulls","title":"<code>drop_nulls()</code>","text":"<p>Remove missing values.</p> Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n</code></pre> <pre><code>&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [2.0, 4.0, float(\"nan\"), 3.0, None, 5.0]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [2.0, 4.0, float(\"nan\"), 3.0, None, 5.0]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\").drop_nulls())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n     a\n0  2.0\n1  4.0\n3  3.0\n5  5.0\n&gt;&gt;&gt; func(df_pl)  # nan != null for polars\nshape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2.0 \u2502\n\u2502 4.0 \u2502\n\u2502 NaN \u2502\n\u2502 3.0 \u2502\n\u2502 5.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.fill_null","title":"<code>fill_null(value)</code>","text":"<p>Fill null values with given value.</p> Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame(\n...     {\"a\": [2, 4, None, 3, 5], \"b\": [2.0, 4.0, float(\"nan\"), 3.0, 5.0]}\n... )\n&gt;&gt;&gt; df_pl = pl.DataFrame(\n...     {\"a\": [2, 4, None, 3, 5], \"b\": [2.0, 4.0, float(\"nan\"), 3.0, 5.0]}\n... )\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(nw.col(\"a\", \"b\").fill_null(0))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n     a    b\n0  2.0  2.0\n1  4.0  4.0\n2  0.0  0.0\n3  3.0  3.0\n4  5.0  5.0\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)  # nan != null for polars\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2506 2.0 \u2502\n\u2502 4   \u2506 4.0 \u2502\n\u2502 0   \u2506 NaN \u2502\n\u2502 3   \u2506 3.0 \u2502\n\u2502 5   \u2506 5.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.filter","title":"<code>filter(*predicates)</code>","text":"<p>Filters elements based on a condition, returning a new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [2, 3, 4, 5, 6, 7], \"b\": [10, 11, 12, 13, 14, 15]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [2, 3, 4, 5, 6, 7], \"b\": [10, 11, 12, 13, 14, 15]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(\n...         nw.col(\"a\").filter(nw.col(\"a\") &gt; 4),\n...         nw.col(\"b\").filter(nw.col(\"b\") &lt; 13),\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a   b\n3  5  10\n4  6  11\n5  7  12\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 5   \u2506 10  \u2502\n\u2502 6   \u2506 11  \u2502\n\u2502 7   \u2506 12  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.head","title":"<code>head(n=10)</code>","text":"<p>Get the first <code>n</code> rows.</p> <p>Arguments     n : int         Number of rows to return.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": list(range(10))}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function that returns the first 3 rows:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\").head(3))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a\n0  0\n1  1\n2  2\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0   \u2502\n\u2502 1   \u2502\n\u2502 2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.is_between","title":"<code>is_between(lower_bound, upper_bound, closed='both')</code>","text":"<p>Check if this expression is between the given lower and upper bounds.</p> <p>Parameters:</p> Name Type Description Default <code>lower_bound</code> <code>Any</code> <p>Lower bound value.</p> required <code>upper_bound</code> <code>Any</code> <p>Upper bound value.</p> required <code>closed</code> <code>str</code> <p>Define which sides of the interval are closed (inclusive).</p> <code>'both'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2, 3, 4, 5]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2, 3, 4, 5]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\").is_between(2, 4, \"right\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n       a\n0  False\n1  False\n2   True\n3   True\n4  False\n&gt;&gt;&gt; func(df_pl)\nshape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a     \u2502\n\u2502 ---   \u2502\n\u2502 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 false \u2502\n\u2502 false \u2502\n\u2502 true  \u2502\n\u2502 true  \u2502\n\u2502 false \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.is_duplicated","title":"<code>is_duplicated()</code>","text":"<p>Return a boolean mask indicating duplicated values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3, 1], \"b\": [\"a\", \"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.all().is_duplicated())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n       a      b\n0   True   True\n1  False   True\n2  False  False\n3   True  False\n&gt;&gt;&gt; func(df_pl)\nshape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a     \u2506 b     \u2502\n\u2502 ---   \u2506 ---   \u2502\n\u2502 bool  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 true  \u2506 true  \u2502\n\u2502 false \u2506 true  \u2502\n\u2502 false \u2506 false \u2502\n\u2502 true  \u2506 false \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.is_first_distinct","title":"<code>is_first_distinct()</code>","text":"<p>Return a boolean mask indicating the first occurrence of each distinct value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3, 1], \"b\": [\"a\", \"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.all().is_first_distinct())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n       a      b\n0   True   True\n1   True  False\n2   True   True\n3  False   True\n&gt;&gt;&gt; func(df_pl)\nshape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a     \u2506 b     \u2502\n\u2502 ---   \u2506 ---   \u2502\n\u2502 bool  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 true  \u2506 true  \u2502\n\u2502 true  \u2506 false \u2502\n\u2502 true  \u2506 true  \u2502\n\u2502 false \u2506 true  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.is_in","title":"<code>is_in(other)</code>","text":"<p>Check if elements of this expression are present in the other iterable.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>iterable</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2, 9, 10]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2, 9, 10]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(b=nw.col(\"a\").is_in([1, 2]))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n    a      b\n0   1   True\n1   2   True\n2   9  False\n3  10  False\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b     \u2502\n\u2502 --- \u2506 ---   \u2502\n\u2502 i64 \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 true  \u2502\n\u2502 2   \u2506 true  \u2502\n\u2502 9   \u2506 false \u2502\n\u2502 10  \u2506 false \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.is_last_distinct","title":"<code>is_last_distinct()</code>","text":"<p>Return a boolean mask indicating the last occurrence of each distinct value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3, 1], \"b\": [\"a\", \"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.all().is_last_distinct())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n       a      b\n0  False  False\n1   True   True\n2   True   True\n3   True   True\n&gt;&gt;&gt; func(df_pl)\nshape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a     \u2506 b     \u2502\n\u2502 ---   \u2506 ---   \u2502\n\u2502 bool  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 false \u2506 false \u2502\n\u2502 true  \u2506 true  \u2502\n\u2502 true  \u2506 true  \u2502\n\u2502 true  \u2506 true  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.is_null","title":"<code>is_null()</code>","text":"<p>Returns a boolean Series indicating which values are null.</p> Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame(\n...     {\"a\": [2, 4, None, 3, 5], \"b\": [2.0, 4.0, float(\"nan\"), 3.0, 5.0]}\n... )\n&gt;&gt;&gt; df_pl = pl.DataFrame(\n...     {\"a\": [2, 4, None, 3, 5], \"b\": [2.0, 4.0, float(\"nan\"), 3.0, 5.0]}\n... )\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         a_is_null=nw.col(\"a\").is_null(), b_is_null=nw.col(\"b\").is_null()\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n     a    b  a_is_null  b_is_null\n0  2.0  2.0      False      False\n1  4.0  4.0      False      False\n2  NaN  NaN       True       True\n3  3.0  3.0      False      False\n4  5.0  5.0      False      False\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)  # nan != null for polars\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b   \u2506 a_is_null \u2506 b_is_null \u2502\n\u2502 ---  \u2506 --- \u2506 ---       \u2506 ---       \u2502\n\u2502 i64  \u2506 f64 \u2506 bool      \u2506 bool      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2    \u2506 2.0 \u2506 false     \u2506 false     \u2502\n\u2502 4    \u2506 4.0 \u2506 false     \u2506 false     \u2502\n\u2502 null \u2506 NaN \u2506 true      \u2506 false     \u2502\n\u2502 3    \u2506 3.0 \u2506 false     \u2506 false     \u2502\n\u2502 5    \u2506 5.0 \u2506 false     \u2506 false     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.is_unique","title":"<code>is_unique()</code>","text":"<p>Return a boolean mask indicating unique values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3, 1], \"b\": [\"a\", \"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.all().is_unique())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n       a      b\n0  False  False\n1   True  False\n2   True   True\n3  False   True\n&gt;&gt;&gt; func(df_pl)\nshape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a     \u2506 b     \u2502\n\u2502 ---   \u2506 ---   \u2502\n\u2502 bool  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 false \u2506 false \u2502\n\u2502 true  \u2506 false \u2502\n\u2502 true  \u2506 true  \u2502\n\u2502 false \u2506 true  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.len","title":"<code>len()</code>","text":"<p>Return the number of elements in the column.</p> <p>Null values count towards the total.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": [\"x\", \"y\", \"z\"], \"b\": [1, 2, 1]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function that computes the len over different values of \"b\" column:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(\n...         nw.col(\"a\").filter(nw.col(\"b\") == 1).len().alias(\"a1\"),\n...         nw.col(\"a\").filter(nw.col(\"b\") == 2).len().alias(\"a2\"),\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n    a1  a2\n0    2   1\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a1  \u2506 a2  \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 u32 \u2506 u32 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2506 1   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.max","title":"<code>max()</code>","text":"<p>Returns the maximum value(s) from a column(s).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [10, 20], \"b\": [50, 100]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [10, 20], \"b\": [50, 100]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.max(\"a\", \"b\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n    a    b\n0  20  100\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 20  \u2506 100 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.mean","title":"<code>mean()</code>","text":"<p>Get mean value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [-1, 0, 1], \"b\": [2, 4, 6]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [-1, 0, 1], \"b\": [2, 4, 6]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\", \"b\").mean())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n     a    b\n0  0.0  4.0\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 f64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0.0 \u2506 4.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.min","title":"<code>min()</code>","text":"<p>Returns the minimum value(s) from a column(s).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2], \"b\": [4, 3]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2], \"b\": [4, 3]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.min(\"a\", \"b\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n0  1  3\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.null_count","title":"<code>null_count()</code>","text":"<p>Count null values.</p> Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": [1, 2, None, 1], \"b\": [\"a\", None, \"b\", None]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.all().null_count())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n0  1  2\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 u32 \u2506 u32 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.n_unique","title":"<code>n_unique()</code>","text":"<p>Returns count of unique values</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2, 3, 4, 5], \"b\": [1, 1, 3, 3, 5]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2, 3, 4, 5], \"b\": [1, 1, 3, 3, 5]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\", \"b\").n_unique())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n0  5  3\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 u32 \u2506 u32 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 5   \u2506 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.over","title":"<code>over(*keys)</code>","text":"<p>Compute expressions over the given groups.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>str | Iterable[str]</code> <p>Names of columns to compute window expression over.   Must be names of columns, as opposed to expressions -   so, this is a bit less flexible than Polars' <code>Expr.over</code>.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3], \"b\": [1, 1, 2]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(a_min_per_group=nw.col(\"a\").min().over(\"b\"))\n</code></pre> <p>We can then pass either pandas or Polars:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b  a_min_per_group\n0  1  1                1\n1  2  1                1\n2  3  2                3\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 a_min_per_group \u2502\n\u2502 --- \u2506 --- \u2506 ---             \u2502\n\u2502 i64 \u2506 i64 \u2506 i64             \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 1   \u2506 1               \u2502\n\u2502 2   \u2506 1   \u2506 1               \u2502\n\u2502 3   \u2506 2   \u2506 3               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.quantile","title":"<code>quantile(quantile, interpolation)</code>","text":"<p>Get quantile value.</p> Note <p>pandas and Polars may have implementation differences for a given interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>quantile</code> <p>float Quantile between 0.0 and 1.0.</p> required <code>interpolation</code> <p>{'nearest', 'higher', 'lower', 'midpoint', 'linear'} Interpolation method.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": list(range(50)), \"b\": list(range(50, 100))}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\", \"b\").quantile(0.5, interpolation=\"linear\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n    a   b\n0  24.5  74.5\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b    \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 f64  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 24.5 \u2506 74.5 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.round","title":"<code>round(decimals=0)</code>","text":"<p>Round underlying floating point data by <code>decimals</code> digits.</p> <p>Parameters:</p> Name Type Description Default <code>decimals</code> <code>int</code> <p>Number of decimals to round by.</p> <code>0</code> Notes <p>For values exactly halfway between rounded decimal values pandas and Polars behave differently.</p> <p>pandas rounds to the nearest even value (e.g. -0.5 and 0.5 round to 0.0, 1.5 and 2.5 round to 2.0, 3.5 and 4.5 to 4.0, etc..).</p> <p>Polars rounds away from 0 (e.g. -0.5 to -1.0, 0.5 to 1.0, 1.5 to 2.0, 2.5 to 3.0, etc..).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": [1.12345, 2.56789, 3.901234]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function that rounds to the first decimal:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\").round(1))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n     a\n0  1.1\n1  2.6\n2  3.9\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.1 \u2502\n\u2502 2.6 \u2502\n\u2502 3.9 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.sample","title":"<code>sample(n=None, fraction=None, *, with_replacement=False)</code>","text":"<p>Sample randomly from this expression.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | None</code> <p>Number of items to return. Cannot be used with fraction.</p> <code>None</code> <code>fraction</code> <code>float | None</code> <p>Fraction of items to return. Cannot be used with n.</p> <code>None</code> <code>with_replacement</code> <code>bool</code> <p>Allow values to be sampled more than once.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n</code></pre> <pre><code>&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2, 3]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\").sample(fraction=1.0, with_replacement=True))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a\n2  3\n0  1\n2  3\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2502\n\u2502 3   \u2502\n\u2502 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.shift","title":"<code>shift(n)</code>","text":"<p>Shift values by <code>n</code> positions.</p> Notes <p>pandas may change the dtype here, for example when introducing missing values in an integer column. To ensure, that the dtype doesn't change, you may want to use <code>fill_null</code> and <code>cast</code>. For example, to shift and fill missing values with <code>0</code> in a Int64 column, you could do:</p> <pre><code>nw.col(\"a\").shift(1).fill_null(0).cast(nw.Int64)\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 1, 3, 5, 5]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 1, 3, 5, 5]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(a_shift=nw.col(\"a\").shift(n=1))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a_shift\n0      NaN\n1      1.0\n2      1.0\n3      3.0\n4      5.0\n&gt;&gt;&gt; func(df_pl)\nshape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a_shift \u2502\n\u2502 ---     \u2502\n\u2502 i64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 null    \u2502\n\u2502 1       \u2502\n\u2502 1       \u2502\n\u2502 3       \u2502\n\u2502 5       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.sort","title":"<code>sort(*, descending=False)</code>","text":"<p>Sort this column. Place null values first.</p> <p>Parameters:</p> Name Type Description Default <code>descending</code> <code>bool</code> <p>Sort in descending order.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n</code></pre> <pre><code>&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [5, None, 1, 2]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [5, None, 1, 2]})\n</code></pre> <p>Let's define dataframe-agnostic functions:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\").sort())\n</code></pre> <pre><code>&gt;&gt;&gt; def func_descend(df_any):\n...     df = nw.from_native(df_any)\n...     df = df.select(nw.col(\"a\").sort(descending=True))\n...     return nw.to_native(df)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n     a\n1  NaN\n2  1.0\n3  2.0\n0  5.0\n&gt;&gt;&gt; func(df_pl)\nshape: (4, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2502\n\u2502 ---  \u2502\n\u2502 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 null \u2502\n\u2502 1    \u2502\n\u2502 2    \u2502\n\u2502 5    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; func_descend(df_pd)\n     a\n1  NaN\n0  5.0\n3  2.0\n2  1.0\n&gt;&gt;&gt; func_descend(df_pl)\nshape: (4, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2502\n\u2502 ---  \u2502\n\u2502 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 null \u2502\n\u2502 5    \u2502\n\u2502 2    \u2502\n\u2502 1    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.std","title":"<code>std(*, ddof=1)</code>","text":"<p>Get standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>ddof</code> <code>int</code> <p>\u201cDelta Degrees of Freedom\u201d: the divisor used in the calculation is N - ddof,      where N represents the number of elements. By default ddof is 1.</p> <code>1</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [20, 25, 60], \"b\": [1.5, 1, -1.4]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [20, 25, 60], \"b\": [1.5, 1, -1.4]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\", \"b\").std(ddof=0))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n          a         b\n0  17.79513  1.265789\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a        \u2506 b        \u2502\n\u2502 ---      \u2506 ---      \u2502\n\u2502 f64      \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 17.79513 \u2506 1.265789 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.sum","title":"<code>sum()</code>","text":"<p>Return the sum value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [5, 10], \"b\": [50, 100]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [5, 10], \"b\": [50, 100]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\", \"b\").sum())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n    a    b\n0  15  150\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 15  \u2506 150 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.tail","title":"<code>tail(n=10)</code>","text":"<p>Get the last <code>n</code> rows.</p> <p>Arguments     n : int         Number of rows to return.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": list(range(10))}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function that returns the last 3 rows:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\").tail(3))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n     a\n7  7\n8  8\n9  9\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 7   \u2502\n\u2502 8   \u2502\n\u2502 9   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions/#narwhals.Expr.unique","title":"<code>unique()</code>","text":"<p>Return unique values</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 1, 3, 5, 5], \"b\": [2, 4, 4, 6, 6]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 1, 3, 5, 5], \"b\": [2, 4, 4, 6, 6]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\", \"b\").unique())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n0  1  2\n1  3  4\n2  5  6\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 2   \u2502\n\u2502 3   \u2506 4   \u2502\n\u2502 5   \u2506 6   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_cat/","title":"<code>narwhals.Expr.cat</code>","text":""},{"location":"api-reference/expressions_cat/#narwhals.expression.ExprCatNamespace.get_categories","title":"<code>get_categories()</code>","text":"<p>Get unique categories from column.</p> <p>Examples:</p> <p>Let's create some dataframes:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"fruits\": [\"apple\", \"mango\", \"mango\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data, dtype=\"category\")\n&gt;&gt;&gt; df_pl = pl.DataFrame(data, schema={\"fruits\": pl.Categorical})\n</code></pre> <p>We define a dataframe-agnostic function to get unique categories from column 'fruits':</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"fruits\").cat.get_categories())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n  fruits\n0  apple\n1  mango\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 fruits \u2502\n\u2502 ---    \u2502\n\u2502 str    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 apple  \u2502\n\u2502 mango  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_dt/","title":"<code>narwhals.Expr.dt</code>","text":""},{"location":"api-reference/expressions_dt/#narwhals.expression.ExprDateTimeNamespace.year","title":"<code>year()</code>","text":"<p>Extract year from underlying DateTime representation.</p> <p>Returns the year number in the calendar date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"datetime\": [\n...         datetime(1978, 6, 1),\n...         datetime(2024, 12, 13),\n...         datetime(2065, 1, 1),\n...     ]\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(nw.col(\"datetime\").dt.year().alias(\"year\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n    datetime  year\n0 1978-06-01  1978\n1 2024-12-13  2024\n2 2065-01-01  2065\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 datetime            \u2506 year \u2502\n\u2502 ---                 \u2506 ---  \u2502\n\u2502 datetime[\u03bcs]        \u2506 i32  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1978-06-01 00:00:00 \u2506 1978 \u2502\n\u2502 2024-12-13 00:00:00 \u2506 2024 \u2502\n\u2502 2065-01-01 00:00:00 \u2506 2065 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_dt/#narwhals.expression.ExprDateTimeNamespace.month","title":"<code>month()</code>","text":"<p>Extract month from underlying DateTime representation.</p> <p>Returns the month number starting from 1. The return value ranges from 1 to 12.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"datetime\": [\n...         datetime(1978, 6, 1),\n...         datetime(2024, 12, 13),\n...         datetime(2065, 1, 1),\n...     ]\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         nw.col(\"datetime\").dt.year().alias(\"year\"),\n...         nw.col(\"datetime\").dt.month().alias(\"month\"),\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n    datetime  year  month\n0 1978-06-01  1978      6\n1 2024-12-13  2024     12\n2 2065-01-01  2065      1\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 datetime            \u2506 year \u2506 month \u2502\n\u2502 ---                 \u2506 ---  \u2506 ---   \u2502\n\u2502 datetime[\u03bcs]        \u2506 i32  \u2506 i8    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1978-06-01 00:00:00 \u2506 1978 \u2506 6     \u2502\n\u2502 2024-12-13 00:00:00 \u2506 2024 \u2506 12    \u2502\n\u2502 2065-01-01 00:00:00 \u2506 2065 \u2506 1     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_dt/#narwhals.expression.ExprDateTimeNamespace.day","title":"<code>day()</code>","text":"<p>Extract day from underlying DateTime representation.</p> <p>Returns the day of month starting from 1. The return value ranges from 1 to 31. (The last day of month differs by months.)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"datetime\": [\n...         datetime(1978, 6, 1),\n...         datetime(2024, 12, 13),\n...         datetime(2065, 1, 1),\n...     ]\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         nw.col(\"datetime\").dt.year().alias(\"year\"),\n...         nw.col(\"datetime\").dt.month().alias(\"month\"),\n...         nw.col(\"datetime\").dt.day().alias(\"day\"),\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n    datetime  year  month  day\n0 1978-06-01  1978      6    1\n1 2024-12-13  2024     12   13\n2 2065-01-01  2065      1    1\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 datetime            \u2506 year \u2506 month \u2506 day \u2502\n\u2502 ---                 \u2506 ---  \u2506 ---   \u2506 --- \u2502\n\u2502 datetime[\u03bcs]        \u2506 i32  \u2506 i8    \u2506 i8  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1978-06-01 00:00:00 \u2506 1978 \u2506 6     \u2506 1   \u2502\n\u2502 2024-12-13 00:00:00 \u2506 2024 \u2506 12    \u2506 13  \u2502\n\u2502 2065-01-01 00:00:00 \u2506 2065 \u2506 1     \u2506 1   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_dt/#narwhals.expression.ExprDateTimeNamespace.ordinal_day","title":"<code>ordinal_day()</code>","text":"<p>Get ordinal day.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [datetime(2020, 1, 1), datetime(2020, 8, 3)]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(a_ordinal_day=nw.col(\"a\").dt.ordinal_day())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n           a  a_ordinal_day\n0 2020-01-01              1\n1 2020-08-03            216\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a                   \u2506 a_ordinal_day \u2502\n\u2502 ---                 \u2506 ---           \u2502\n\u2502 datetime[\u03bcs]        \u2506 i16           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-01-01 00:00:00 \u2506 1             \u2502\n\u2502 2020-08-03 00:00:00 \u2506 216           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_dt/#narwhals.expression.ExprDateTimeNamespace.hour","title":"<code>hour()</code>","text":"<p>Extract hour from underlying DateTime representation.</p> <p>Returns the hour number from 0 to 23.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"datetime\": [\n...         datetime(1978, 1, 1, 1),\n...         datetime(2024, 10, 13, 5),\n...         datetime(2065, 1, 1, 10),\n...     ]\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(nw.col(\"datetime\").dt.hour().alias(\"hour\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n             datetime  hour\n0 1978-01-01 01:00:00     1\n1 2024-10-13 05:00:00     5\n2 2065-01-01 10:00:00    10\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 datetime            \u2506 hour \u2502\n\u2502 ---                 \u2506 ---  \u2502\n\u2502 datetime[\u03bcs]        \u2506 i8   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1978-01-01 01:00:00 \u2506 1    \u2502\n\u2502 2024-10-13 05:00:00 \u2506 5    \u2502\n\u2502 2065-01-01 10:00:00 \u2506 10   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_dt/#narwhals.expression.ExprDateTimeNamespace.minute","title":"<code>minute()</code>","text":"<p>Extract minutes from underlying DateTime representation.</p> <p>Returns the minute number from 0 to 59.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"datetime\": [\n...         datetime(1978, 1, 1, 1, 1),\n...         datetime(2024, 10, 13, 5, 30),\n...         datetime(2065, 1, 1, 10, 20),\n...     ]\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         nw.col(\"datetime\").dt.hour().alias(\"hour\"),\n...         nw.col(\"datetime\").dt.minute().alias(\"minute\"),\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n             datetime  hour  minute\n0 1978-01-01 01:01:00     1       1\n1 2024-10-13 05:30:00     5      30\n2 2065-01-01 10:20:00    10      20\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 datetime            \u2506 hour \u2506 minute \u2502\n\u2502 ---                 \u2506 ---  \u2506 ---    \u2502\n\u2502 datetime[\u03bcs]        \u2506 i8   \u2506 i8     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1978-01-01 01:01:00 \u2506 1    \u2506 1      \u2502\n\u2502 2024-10-13 05:30:00 \u2506 5    \u2506 30     \u2502\n\u2502 2065-01-01 10:20:00 \u2506 10   \u2506 20     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_dt/#narwhals.expression.ExprDateTimeNamespace.second","title":"<code>second()</code>","text":"<p>Extract seconds from underlying DateTime representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"datetime\": [\n...         datetime(1978, 1, 1, 1, 1, 1),\n...         datetime(2024, 10, 13, 5, 30, 14),\n...         datetime(2065, 1, 1, 10, 20, 30),\n...     ]\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         nw.col(\"datetime\").dt.hour().alias(\"hour\"),\n...         nw.col(\"datetime\").dt.minute().alias(\"minute\"),\n...         nw.col(\"datetime\").dt.second().alias(\"second\"),\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n             datetime  hour  minute  second\n0 1978-01-01 01:01:01     1       1       1\n1 2024-10-13 05:30:14     5      30      14\n2 2065-01-01 10:20:30    10      20      30\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 datetime            \u2506 hour \u2506 minute \u2506 second \u2502\n\u2502 ---                 \u2506 ---  \u2506 ---    \u2506 ---    \u2502\n\u2502 datetime[\u03bcs]        \u2506 i8   \u2506 i8     \u2506 i8     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1978-01-01 01:01:01 \u2506 1    \u2506 1      \u2506 1      \u2502\n\u2502 2024-10-13 05:30:14 \u2506 5    \u2506 30     \u2506 14     \u2502\n\u2502 2065-01-01 10:20:30 \u2506 10   \u2506 20     \u2506 30     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_dt/#narwhals.expression.ExprDateTimeNamespace.millisecond","title":"<code>millisecond()</code>","text":"<p>Extract milliseconds from underlying DateTime representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"datetime\": [\n...         datetime(1978, 1, 1, 1, 1, 1, 0),\n...         datetime(2024, 10, 13, 5, 30, 14, 505000),\n...         datetime(2065, 1, 1, 10, 20, 30, 67000),\n...     ]\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         nw.col(\"datetime\").dt.hour().alias(\"hour\"),\n...         nw.col(\"datetime\").dt.minute().alias(\"minute\"),\n...         nw.col(\"datetime\").dt.second().alias(\"second\"),\n...         nw.col(\"datetime\").dt.millisecond().alias(\"millisecond\"),\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n                 datetime  hour  minute  second  millisecond\n0 1978-01-01 01:01:01.000     1       1       1            0\n1 2024-10-13 05:30:14.505     5      30      14          505\n2 2065-01-01 10:20:30.067    10      20      30           67\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 datetime                \u2506 hour \u2506 minute \u2506 second \u2506 millisecond \u2502\n\u2502 ---                     \u2506 ---  \u2506 ---    \u2506 ---    \u2506 ---         \u2502\n\u2502 datetime[\u03bcs]            \u2506 i8   \u2506 i8     \u2506 i8     \u2506 i32         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1978-01-01 01:01:01     \u2506 1    \u2506 1      \u2506 1      \u2506 0           \u2502\n\u2502 2024-10-13 05:30:14.505 \u2506 5    \u2506 30     \u2506 14     \u2506 505         \u2502\n\u2502 2065-01-01 10:20:30.067 \u2506 10   \u2506 20     \u2506 30     \u2506 67          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_dt/#narwhals.expression.ExprDateTimeNamespace.microsecond","title":"<code>microsecond()</code>","text":"<p>Extract microseconds from underlying DateTime representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"datetime\": [\n...         datetime(1978, 1, 1, 1, 1, 1, 0),\n...         datetime(2024, 10, 13, 5, 30, 14, 505000),\n...         datetime(2065, 1, 1, 10, 20, 30, 67000),\n...     ]\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         nw.col(\"datetime\").dt.hour().alias(\"hour\"),\n...         nw.col(\"datetime\").dt.minute().alias(\"minute\"),\n...         nw.col(\"datetime\").dt.second().alias(\"second\"),\n...         nw.col(\"datetime\").dt.microsecond().alias(\"microsecond\"),\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n                 datetime  hour  minute  second  microsecond\n0 1978-01-01 01:01:01.000     1       1       1            0\n1 2024-10-13 05:30:14.505     5      30      14       505000\n2 2065-01-01 10:20:30.067    10      20      30        67000\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 datetime                \u2506 hour \u2506 minute \u2506 second \u2506 microsecond \u2502\n\u2502 ---                     \u2506 ---  \u2506 ---    \u2506 ---    \u2506 ---         \u2502\n\u2502 datetime[\u03bcs]            \u2506 i8   \u2506 i8     \u2506 i8     \u2506 i32         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1978-01-01 01:01:01     \u2506 1    \u2506 1      \u2506 1      \u2506 0           \u2502\n\u2502 2024-10-13 05:30:14.505 \u2506 5    \u2506 30     \u2506 14     \u2506 505000      \u2502\n\u2502 2065-01-01 10:20:30.067 \u2506 10   \u2506 20     \u2506 30     \u2506 67000       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_dt/#narwhals.expression.ExprDateTimeNamespace.nanosecond","title":"<code>nanosecond()</code>","text":"<p>Extract Nanoseconds from underlying DateTime representation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"datetime\": [\n...         datetime(1978, 1, 1, 1, 1, 1, 0),\n...         datetime(2024, 10, 13, 5, 30, 14, 500000),\n...         datetime(2065, 1, 1, 10, 20, 30, 60000),\n...     ]\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         nw.col(\"datetime\").dt.hour().alias(\"hour\"),\n...         nw.col(\"datetime\").dt.minute().alias(\"minute\"),\n...         nw.col(\"datetime\").dt.second().alias(\"second\"),\n...         nw.col(\"datetime\").dt.nanosecond().alias(\"nanosecond\"),\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n                 datetime  hour  minute  second  nanosecond\n0 1978-01-01 01:01:01.000     1       1       1           0\n1 2024-10-13 05:30:14.500     5      30      14   500000000\n2 2065-01-01 10:20:30.060    10      20      30    60000000\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 datetime                \u2506 hour \u2506 minute \u2506 second \u2506 nanosecond \u2502\n\u2502 ---                     \u2506 ---  \u2506 ---    \u2506 ---    \u2506 ---        \u2502\n\u2502 datetime[\u03bcs]            \u2506 i8   \u2506 i8     \u2506 i8     \u2506 i32        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1978-01-01 01:01:01     \u2506 1    \u2506 1      \u2506 1      \u2506 0          \u2502\n\u2502 2024-10-13 05:30:14.500 \u2506 5    \u2506 30     \u2506 14     \u2506 500000000  \u2502\n\u2502 2065-01-01 10:20:30.060 \u2506 10   \u2506 20     \u2506 30     \u2506 60000000   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_dt/#narwhals.expression.ExprDateTimeNamespace.total_minutes","title":"<code>total_minutes()</code>","text":"<p>Get total minutes.</p> Notes <p>The function outputs the total minutes in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> and <code>cast</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [timedelta(minutes=10), timedelta(minutes=20, seconds=40)]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(a_total_minutes=nw.col(\"a\").dt.total_minutes())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n                a  a_total_minutes\n0 0 days 00:10:00               10\n1 0 days 00:20:40               20\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a            \u2506 a_total_minutes \u2502\n\u2502 ---          \u2506 ---             \u2502\n\u2502 duration[\u03bcs] \u2506 i64             \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 10m          \u2506 10              \u2502\n\u2502 20m 40s      \u2506 20              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_dt/#narwhals.expression.ExprDateTimeNamespace.total_seconds","title":"<code>total_seconds()</code>","text":"<p>Get total seconds.</p> Notes <p>The function outputs the total seconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> and <code>cast</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [timedelta(seconds=10), timedelta(seconds=20, milliseconds=40)]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(a_total_seconds=nw.col(\"a\").dt.total_seconds())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n                       a  a_total_seconds\n0        0 days 00:00:10               10\n1 0 days 00:00:20.040000               20\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a            \u2506 a_total_seconds \u2502\n\u2502 ---          \u2506 ---             \u2502\n\u2502 duration[\u03bcs] \u2506 i64             \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 10s          \u2506 10              \u2502\n\u2502 20s 40ms     \u2506 20              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_dt/#narwhals.expression.ExprDateTimeNamespace.total_milliseconds","title":"<code>total_milliseconds()</code>","text":"<p>Get total milliseconds.</p> Notes <p>The function outputs the total milliseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> and <code>cast</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"a\": [\n...         timedelta(milliseconds=10),\n...         timedelta(milliseconds=20, microseconds=40),\n...     ]\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         a_total_milliseconds=nw.col(\"a\").dt.total_milliseconds()\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n                       a  a_total_milliseconds\n0 0 days 00:00:00.010000                    10\n1 0 days 00:00:00.020040                    20\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a            \u2506 a_total_milliseconds \u2502\n\u2502 ---          \u2506 ---                  \u2502\n\u2502 duration[\u03bcs] \u2506 i64                  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 10ms         \u2506 10                   \u2502\n\u2502 20040\u00b5s      \u2506 20                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_dt/#narwhals.expression.ExprDateTimeNamespace.total_microseconds","title":"<code>total_microseconds()</code>","text":"<p>Get total microseconds.</p> Notes <p>The function outputs the total microseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> and <code>cast</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"a\": [\n...         timedelta(microseconds=10),\n...         timedelta(milliseconds=1, microseconds=200),\n...     ]\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         a_total_microseconds=nw.col(\"a\").dt.total_microseconds()\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n                       a  a_total_microseconds\n0 0 days 00:00:00.000010                    10\n1 0 days 00:00:00.001200                  1200\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a            \u2506 a_total_microseconds \u2502\n\u2502 ---          \u2506 ---                  \u2502\n\u2502 duration[\u03bcs] \u2506 i64                  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 10\u00b5s         \u2506 10                   \u2502\n\u2502 1200\u00b5s       \u2506 1200                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_dt/#narwhals.expression.ExprDateTimeNamespace.total_nanoseconds","title":"<code>total_nanoseconds()</code>","text":"<p>Get total nanoseconds.</p> Notes <p>The function outputs the total nanoseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> and <code>cast</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [\"2024-01-01 00:00:00.000000001\", \"2024-01-01 00:00:00.000000002\"]\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": pd.to_datetime(data)})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": data}).with_columns(\n...     pl.col(\"a\").str.to_datetime(time_unit=\"ns\")\n... )\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         a_diff_total_nanoseconds=nw.col(\"a\").diff().dt.total_nanoseconds()\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n                              a  a_diff_total_nanoseconds\n0 2024-01-01 00:00:00.000000001                       NaN\n1 2024-01-01 00:00:00.000000002                       1.0\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a                             \u2506 a_diff_total_nanoseconds \u2502\n\u2502 ---                           \u2506 ---                      \u2502\n\u2502 datetime[ns]                  \u2506 i64                      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-01-01 00:00:00.000000001 \u2506 null                     \u2502\n\u2502 2024-01-01 00:00:00.000000002 \u2506 1                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_dt/#narwhals.expression.ExprDateTimeNamespace.to_string","title":"<code>to_string(format)</code>","text":"<p>Convert a Date/Time/Datetime column into a String column with the given format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [\n...     datetime(2020, 3, 1),\n...     datetime(2020, 4, 1),\n...     datetime(2020, 5, 1),\n... ]\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": data})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": data})\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\").dt.to_string(\"%Y/%m/%d %H:%M:%S\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n                     a\n0  2020/03/01 00:00:00\n1  2020/04/01 00:00:00\n2  2020/05/01 00:00:00\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a                   \u2502\n\u2502 ---                 \u2502\n\u2502 str                 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020/03/01 00:00:00 \u2502\n\u2502 2020/04/01 00:00:00 \u2502\n\u2502 2020/05/01 00:00:00 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_str/","title":"<code>narwhals.Expr.str</code>","text":""},{"location":"api-reference/expressions_str/#narwhals.expression.ExprStringNamespace.contains","title":"<code>contains(pattern, *, literal=False)</code>","text":"<p>Check if string contains a substring that matches a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>A Character sequence or valid regular expression pattern.</p> required <code>literal</code> <code>bool</code> <p>If True, treats the pattern as a literal string.      If False, assumes the pattern is a regular expression.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"pets\": [\"cat\", \"dog\", \"rabbit and parrot\", \"dove\", None]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         default_match=nw.col(\"pets\").str.contains(\"parrot|Dove\"),\n...         case_insensitive_match=nw.col(\"pets\").str.contains(\"(?i)parrot|Dove\"),\n...         literal_match=nw.col(\"pets\").str.contains(\n...             \"parrot|Dove\", literal=True\n...         ),\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n                pets default_match case_insensitive_match literal_match\n0                cat         False                  False         False\n1                dog         False                  False         False\n2  rabbit and parrot          True                   True         False\n3               dove         False                   True         False\n4               None          None                   None          None\n&gt;&gt;&gt; func(df_pl)\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 pets              \u2506 default_match \u2506 case_insensitive_match \u2506 literal_match \u2502\n\u2502 ---               \u2506 ---           \u2506 ---                    \u2506 ---           \u2502\n\u2502 str               \u2506 bool          \u2506 bool                   \u2506 bool          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 cat               \u2506 false         \u2506 false                  \u2506 false         \u2502\n\u2502 dog               \u2506 false         \u2506 false                  \u2506 false         \u2502\n\u2502 rabbit and parrot \u2506 true          \u2506 true                   \u2506 false         \u2502\n\u2502 dove              \u2506 false         \u2506 true                   \u2506 false         \u2502\n\u2502 null              \u2506 null          \u2506 null                   \u2506 null          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_str/#narwhals.expression.ExprStringNamespace.ends_with","title":"<code>ends_with(suffix)</code>","text":"<p>Check if string values end with a substring.</p> <p>Parameters:</p> Name Type Description Default <code>suffix</code> <code>str</code> <p>suffix substring</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"fruits\": [\"apple\", \"mango\", None]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(has_suffix=nw.col(\"fruits\").str.ends_with(\"ngo\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n  fruits has_suffix\n0  apple      False\n1  mango       True\n2   None       None\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 fruits \u2506 has_suffix \u2502\n\u2502 ---    \u2506 ---        \u2502\n\u2502 str    \u2506 bool       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 apple  \u2506 false      \u2502\n\u2502 mango  \u2506 true       \u2502\n\u2502 null   \u2506 null       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_str/#narwhals.expression.ExprStringNamespace.head","title":"<code>head(n=5)</code>","text":"<p>Take the first n elements of each string.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to take. Negative indexing is not supported.</p> <code>5</code> Notes <p>If the length of the string has fewer than <code>n</code> characters, the full string is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"lyrics\": [\"Atatata\", \"taata\", \"taatatata\", \"zukkyun\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(lyrics_head=nw.col(\"lyrics\").str.head())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n      lyrics lyrics_head\n0    Atatata       Atata\n1      taata       taata\n2  taatatata       taata\n3    zukkyun       zukky\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 lyrics    \u2506 lyrics_head \u2502\n\u2502 ---       \u2506 ---         \u2502\n\u2502 str       \u2506 str         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Atatata   \u2506 Atata       \u2502\n\u2502 taata     \u2506 taata       \u2502\n\u2502 taatatata \u2506 taata       \u2502\n\u2502 zukkyun   \u2506 zukky       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_str/#narwhals.expression.ExprStringNamespace.slice","title":"<code>slice(offset, length=None)</code>","text":"<p>Create subslices of the string values of an expression.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>Start index. Negative indexing is supported.</p> required <code>length</code> <code>int | None</code> <p>Length of the slice. If set to <code>None</code> (default), the slice is taken to the end of the string.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"s\": [\"pear\", None, \"papaya\", \"dragonfruit\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(s_sliced=nw.col(\"s\").str.slice(4, length=3))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n             s s_sliced\n0         pear\n1         None     None\n2       papaya       ya\n3  dragonfruit      onf\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 s           \u2506 s_sliced \u2502\n\u2502 ---         \u2506 ---      \u2502\n\u2502 str         \u2506 str      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 pear        \u2506          \u2502\n\u2502 null        \u2506 null     \u2502\n\u2502 papaya      \u2506 ya       \u2502\n\u2502 dragonfruit \u2506 onf      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Using negative indexes:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(s_sliced=nw.col(\"s\").str.slice(-3))\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pd)\n             s s_sliced\n0         pear      ear\n1         None     None\n2       papaya      aya\n3  dragonfruit      uit\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 s           \u2506 s_sliced \u2502\n\u2502 ---         \u2506 ---      \u2502\n\u2502 str         \u2506 str      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 pear        \u2506 ear      \u2502\n\u2502 null        \u2506 null     \u2502\n\u2502 papaya      \u2506 aya      \u2502\n\u2502 dragonfruit \u2506 uit      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_str/#narwhals.expression.ExprStringNamespace.starts_with","title":"<code>starts_with(prefix)</code>","text":"<p>Check if string values start with a substring.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>prefix substring</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"fruits\": [\"apple\", \"mango\", None]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(has_prefix=nw.col(\"fruits\").str.starts_with(\"app\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n  fruits has_prefix\n0  apple       True\n1  mango      False\n2   None       None\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 fruits \u2506 has_prefix \u2502\n\u2502 ---    \u2506 ---        \u2502\n\u2502 str    \u2506 bool       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 apple  \u2506 true       \u2502\n\u2502 mango  \u2506 false      \u2502\n\u2502 null   \u2506 null       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_str/#narwhals.expression.ExprStringNamespace.tail","title":"<code>tail(n=5)</code>","text":"<p>Take the last n elements of each string.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to take. Negative indexing is not supported.</p> <code>5</code> Notes <p>If the length of the string has fewer than <code>n</code> characters, the full string is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"lyrics\": [\"Atatata\", \"taata\", \"taatatata\", \"zukkyun\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(lyrics_tail=nw.col(\"lyrics\").str.tail())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n      lyrics lyrics_tail\n0    Atatata       atata\n1      taata       taata\n2  taatatata       atata\n3    zukkyun       kkyun\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 lyrics    \u2506 lyrics_tail \u2502\n\u2502 ---       \u2506 ---         \u2502\n\u2502 str       \u2506 str         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Atatata   \u2506 atata       \u2502\n\u2502 taata     \u2506 taata       \u2502\n\u2502 taatatata \u2506 atata       \u2502\n\u2502 zukkyun   \u2506 kkyun       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expressions_str/#narwhals.expression.ExprStringNamespace.to_datetime","title":"<code>to_datetime(format)</code>","text":"<p>Convert to Datetime dtype.</p> Notes <p>pandas defaults to nanosecond time unit, Polars to microsecond. Prior to pandas 2.0, nanoseconds were the only time unit supported in pandas, with no ability to set any other one. The ability to set the time unit in pandas, if the version permits, will arrive.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>str</code> <p>Format to parse strings with. Must be passed, as different     dataframe libraries have different ways of auto-inferring     formats.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [\"2020-01-01\", \"2020-01-02\"]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [\"2020-01-01\", \"2020-01-02\"]})\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\").str.to_datetime(format=\"%Y-%m-%d\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n           a\n0 2020-01-01\n1 2020-01-02\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a                   \u2502\n\u2502 ---                 \u2502\n\u2502 datetime[\u03bcs]        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-01-01 00:00:00 \u2502\n\u2502 2020-01-02 00:00:00 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/group_by/","title":"<code>narwhals.GroupBy</code>","text":""},{"location":"api-reference/group_by/#narwhals.group_by.GroupBy.agg","title":"<code>agg(*aggs, **named_aggs)</code>","text":"<p>Compute aggregations for each group of a group by operation.</p> <p>Parameters:</p> Name Type Description Default <code>aggs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Aggregations to compute for each group of the group by operation, specified as positional arguments.</p> <code>()</code> <code>named_aggs</code> <code>IntoExpr</code> <p>Additional aggregations, specified as keyword arguments.</p> <code>{}</code> <p>Examples:</p> <p>Group by one column or by multiple columns and call <code>agg</code> to compute the grouped sum of another column.</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame(\n...     {\n...         \"a\": [\"a\", \"b\", \"a\", \"b\", \"c\"],\n...         \"b\": [1, 2, 1, 3, 3],\n...         \"c\": [5, 4, 3, 2, 1],\n...     }\n... )\n&gt;&gt;&gt; df_pl = pl.DataFrame(\n...     {\n...         \"a\": [\"a\", \"b\", \"a\", \"b\", \"c\"],\n...         \"b\": [1, 2, 1, 3, 3],\n...         \"c\": [5, 4, 3, 2, 1],\n...     }\n... )\n</code></pre> <p>We define library agnostic functions:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     df = df.group_by(\"a\").agg(nw.col(\"b\").sum()).sort(\"a\")\n...     return nw.to_native(df)\n</code></pre> <pre><code>&gt;&gt;&gt; def func_mult_col(df_any):\n...     df = nw.from_native(df_any)\n...     df = df.group_by(\"a\", \"b\").agg(nw.sum(\"c\")).sort(\"a\", \"b\")\n...     return nw.to_native(df)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code> and <code>func_mult_col</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n0  a  2\n1  b  5\n2  c  3\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 2   \u2502\n\u2502 b   \u2506 5   \u2502\n\u2502 c   \u2506 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func_mult_col(df_pd)\n   a  b  c\n0  a  1  8\n1  b  2  4\n2  b  3  2\n3  c  3  1\n&gt;&gt;&gt; func_mult_col(df_pl)\nshape: (4, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1   \u2506 8   \u2502\n\u2502 b   \u2506 2   \u2506 4   \u2502\n\u2502 b   \u2506 3   \u2506 2   \u2502\n\u2502 c   \u2506 3   \u2506 1   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/","title":"<code>narwhals.LazyFrame</code>","text":"<p>Narwhals DataFrame, backed by a native dataframe.</p> <p>The native dataframe might be pandas.DataFrame, polars.LazyFrame, ...</p> <p>This class is not meant to be instantiated directly - instead, use <code>narwhals.from_native</code>.</p>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.columns","title":"<code>columns: list[str]</code>  <code>property</code>","text":"<p>Get column names.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(\n...     {\n...         \"foo\": [1, 2, 3],\n...         \"bar\": [6, 7, 8],\n...         \"ham\": [\"a\", \"b\", \"c\"],\n...     }\n... ).select(\"foo\", \"bar\")\n&gt;&gt;&gt; lf = nw.LazyFrame(lf_pl)\n&gt;&gt;&gt; lf.columns\n['foo', 'bar']\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.schema","title":"<code>schema: dict[str, DType]</code>  <code>property</code>","text":"<p>Get a dict[column name, DType].</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(\n...     {\n...         \"foo\": [1, 2, 3],\n...         \"bar\": [6.0, 7.0, 8.0],\n...         \"ham\": [\"a\", \"b\", \"c\"],\n...     }\n... )\n&gt;&gt;&gt; lf = nw.LazyFrame(lf_pl)\n&gt;&gt;&gt; lf.schema\nOrderedDict({'foo': Int64, 'bar': Float64, 'ham': String})\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.collect","title":"<code>collect()</code>","text":"<p>Materialize this LazyFrame into a DataFrame.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(\n...     {\n...         \"a\": [\"a\", \"b\", \"a\", \"b\", \"b\", \"c\"],\n...         \"b\": [1, 2, 3, 4, 5, 6],\n...         \"c\": [6, 5, 4, 3, 2, 1],\n...     }\n... )\n&gt;&gt;&gt; lf = nw.LazyFrame(lf_pl)\n&gt;&gt;&gt; lf\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals LazyFrame                            |\n| Use `narwhals.to_native` to see native output |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; df = lf.group_by(\"a\").agg(nw.all().sum()).collect()\n&gt;&gt;&gt; df\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame                            |\n| Use `narwhals.to_native` to see native output |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; nw.to_native(df).sort(\"a\")\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 4   \u2506 10  \u2502\n\u2502 b   \u2506 11  \u2506 10  \u2502\n\u2502 c   \u2506 6   \u2506 1   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.drop","title":"<code>drop(*columns)</code>","text":"<p>Remove columns from the LazyFrame.</p> <p>Parameters:</p> Name Type Description Default <code>*columns</code> <code>str | Iterable[str]</code> <p>Names of the columns that should be removed from the       dataframe. Accepts column selector input.</p> <code>()</code> <p>Examples:</p> <p>Drop a single column by passing the name of that column.</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(\n...     {\n...         \"foo\": [1, 2, 3],\n...         \"bar\": [6.0, 7.0, 8.0],\n...         \"ham\": [\"a\", \"b\", \"c\"],\n...     }\n... )\n&gt;&gt;&gt; lf = nw.LazyFrame(lf_pl)\n&gt;&gt;&gt; lframe = lf.drop(\"ham\").collect()\n&gt;&gt;&gt; lframe\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame                            |\n| Use `narwhals.to_native` to see native output |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; nw.to_native(lframe)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6.0 \u2502\n\u2502 2   \u2506 7.0 \u2502\n\u2502 3   \u2506 8.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Use positional arguments to drop multiple columns.</p> <pre><code>&gt;&gt;&gt; lframe = lf.drop(\"foo\", \"ham\").collect()\n&gt;&gt;&gt; lframe\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame                            |\n| Use `narwhals.to_native` to see native output |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; nw.to_native(lframe)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 bar \u2502\n\u2502 --- \u2502\n\u2502 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 6.0 \u2502\n\u2502 7.0 \u2502\n\u2502 8.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.drop_nulls","title":"<code>drop_nulls()</code>","text":"<p>Drop null values.</p> Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [1.0, 2.0, None], \"ba\": [1, None, 2.0]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.LazyFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     df = df.drop_nulls()\n...     return nw.to_native(df)\n</code></pre> <p>We can then pass either pandas or Polars:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n     a   ba\n0  1.0  1.0\n&gt;&gt;&gt; func(df_pl).collect()\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 ba  \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 f64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0 \u2506 1.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.filter","title":"<code>filter(*predicates)</code>","text":"<p>Filter the rows in the LazyFrame based on a predicate expression.</p> <p>The original order of the remaining rows is preserved.</p> <p>Parameters:</p> Name Type Description Default <code>*predicates</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Expression that evaluates to a boolean Series.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\n...     \"foo\": [1, 2, 3],\n...     \"bar\": [6, 7, 8],\n...     \"ham\": [\"a\", \"b\", \"c\"],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(df)\n</code></pre> <p>Let's define a dataframe-agnostic function in which we filter on one condition.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.filter(nw.col(\"foo\") &gt; 1)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n1    2    7   b\n2    3    8   c\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2506 7   \u2506 b   \u2502\n\u2502 3   \u2506 8   \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2506 7   \u2506 b   \u2502\n\u2502 3   \u2506 8   \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Filter on multiple conditions:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.filter((nw.col(\"foo\") &lt; 3) &amp; (nw.col(\"ham\") == \"a\"))\n&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n0    1    6   a\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2506 a   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2506 a   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Provide multiple filters using <code>*args</code> syntax:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     dframe = df.filter(\n...         nw.col(\"foo\") == 1,\n...         nw.col(\"ham\") == \"a\",\n...     )\n...     return dframe\n&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n0    1    6   a\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2506 a   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2506 a   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Filter on an OR condition:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.filter((nw.col(\"foo\") == 1) | (nw.col(\"ham\") == \"c\"))\n&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n0    1    6   a\n2    3    8   c\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2506 a   \u2502\n\u2502 3   \u2506 8   \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2506 a   \u2502\n\u2502 3   \u2506 8   \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.group_by","title":"<code>group_by(*keys)</code>","text":"<p>Start a group by operation.</p> <p>Parameters:</p> Name Type Description Default <code>*keys</code> <code>str | Iterable[str]</code> <p>Column(s) to group by. Accepts expression input. Strings are parsed as column names.</p> <code>()</code> <p>Examples:</p> <p>Group by one column and call <code>agg</code> to compute the grouped sum of another column.</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\n...     \"a\": [\"a\", \"b\", \"a\", \"b\", \"c\"],\n...     \"b\": [1, 2, 1, 3, 3],\n...     \"c\": [5, 4, 3, 2, 1],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(df)\n</code></pre> <p>Let's define a dataframe-agnostic function in which we group by one column and call <code>agg</code> to compute the grouped sum of another column.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.group_by(\"a\").agg(nw.col(\"b\").sum()).sort(\"a\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n0  a  2\n1  b  5\n2  c  3\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 2   \u2502\n\u2502 b   \u2506 5   \u2502\n\u2502 c   \u2506 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 2   \u2502\n\u2502 b   \u2506 5   \u2502\n\u2502 c   \u2506 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Group by multiple columns by passing a list of column names.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.group_by([\"a\", \"b\"]).agg(nw.max(\"c\")).sort([\"a\", \"b\"])\n&gt;&gt;&gt; func(df_pd)\n   a  b  c\n0  a  1  5\n1  b  2  4\n2  b  3  2\n3  c  3  1\n&gt;&gt;&gt; func(df_pl)\nshape: (4, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1   \u2506 5   \u2502\n\u2502 b   \u2506 2   \u2506 4   \u2502\n\u2502 b   \u2506 3   \u2506 2   \u2502\n\u2502 c   \u2506 3   \u2506 1   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (4, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1   \u2506 5   \u2502\n\u2502 b   \u2506 2   \u2506 4   \u2502\n\u2502 b   \u2506 3   \u2506 2   \u2502\n\u2502 c   \u2506 3   \u2506 1   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.head","title":"<code>head(n=5)</code>","text":"<p>Get the first <code>n</code> rows.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of rows to return.</p> <code>5</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\n...     \"a\": [1, 2, 3, 4, 5, 6],\n...     \"b\": [7, 8, 9, 10, 11, 12],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function that gets the first 3 rows.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.head(3)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n0  1  7\n1  2  8\n2  3  9\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 7   \u2502\n\u2502 2   \u2506 8   \u2502\n\u2502 3   \u2506 9   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 7   \u2502\n\u2502 2   \u2506 8   \u2502\n\u2502 3   \u2506 9   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.join","title":"<code>join(other, *, how='inner', left_on, right_on)</code>","text":"<p>Add a join operation to the Logical Plan.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Lazy DataFrame to join with.</p> required <code>how</code> <code>Literal['inner']</code> <p>{'inner'}   Join strategy.</p> <ul> <li>inner: Returns rows that have matching values in both               tables</li> </ul> <code>'inner'</code> <code>left_on</code> <code>str | list[str]</code> <p>Join column of the left DataFrame.</p> required <code>right_on</code> <code>str | list[str]</code> <p>Join column of the right DataFrame.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A new joined LazyFrame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(\n...     {\n...         \"foo\": [1, 2, 3],\n...         \"bar\": [6.0, 7.0, 8.0],\n...         \"ham\": [\"a\", \"b\", \"c\"],\n...     }\n... )\n&gt;&gt;&gt; other_lf_pl = pl.LazyFrame(\n...     {\n...         \"apple\": [\"x\", \"y\", \"z\"],\n...         \"ham\": [\"a\", \"b\", \"d\"],\n...     }\n... )\n&gt;&gt;&gt; lf = nw.LazyFrame(lf_pl)\n&gt;&gt;&gt; other_lf = nw.LazyFrame(other_lf_pl)\n&gt;&gt;&gt; lframe = lf.join(other_lf, left_on=\"ham\", right_on=\"ham\").collect()\n&gt;&gt;&gt; lframe\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame                            |\n| Use `narwhals.to_native` to see native output |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; nw.to_native(lframe)\nshape: (2, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2506 apple \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2506 ---   \u2502\n\u2502 i64 \u2506 f64 \u2506 str \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6.0 \u2506 a   \u2506 x     \u2502\n\u2502 2   \u2506 7.0 \u2506 b   \u2506 y     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.pipe","title":"<code>pipe(function, *args, **kwargs)</code>","text":"<p>Pipe function call.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3], \"ba\": [4, 5, 6]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.LazyFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     df = df.pipe(\n...         lambda _df: _df.select([x for x in _df.columns if len(x) == 1])\n...     )\n...     return nw.to_native(df)\n</code></pre> <p>We can then pass either pandas or Polars:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a\n0  1\n1  2\n2  3\n&gt;&gt;&gt; func(df_pl).collect()\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2502\n\u2502 2   \u2502\n\u2502 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.rename","title":"<code>rename(mapping)</code>","text":"<p>Rename column names.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>dict[str, str]</code> <p>Key value pairs that map from old name to new name, or a       function that takes the old name as input and returns the       new name.</p> required Notes <p>If existing names are swapped (e.g. 'A' points to 'B' and 'B'  points to 'A'), polars will block projection and predicate  pushdowns at this node.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(\n...     {\n...         \"foo\": [1, 2, 3],\n...         \"bar\": [6, 7, 8],\n...         \"ham\": [\"a\", \"b\", \"c\"],\n...     }\n... )\n&gt;&gt;&gt; lf = nw.LazyFrame(lf_pl)\n&gt;&gt;&gt; lframe = lf.rename({\"foo\": \"apple\"}).collect()\n&gt;&gt;&gt; lframe\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame                            |\n| Use `narwhals.to_native` to see native output |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; nw.to_native(lframe)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 apple \u2506 bar \u2506 ham \u2502\n\u2502 ---   \u2506 --- \u2506 --- \u2502\n\u2502 i64   \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1     \u2506 6   \u2506 a   \u2502\n\u2502 2     \u2506 7   \u2506 b   \u2502\n\u2502 3     \u2506 8   \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.select","title":"<code>select(*exprs, **named_exprs)</code>","text":"<p>Select columns from this LazyFrame.</p> <p>Parameters:</p> Name Type Description Default <code>*exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Column(s) to select, specified as positional arguments.      Accepts expression input. Strings are parsed as column names,      other non-expression inputs are parsed as literals.</p> <code>()</code> <code>**named_exprs</code> <code>IntoExpr</code> <p>Additional columns to select, specified as keyword arguments.             The columns will be renamed to the keyword used.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\n...     \"foo\": [1, 2, 3],\n...     \"bar\": [6, 7, 8],\n...     \"ham\": [\"a\", \"b\", \"c\"],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(df)\n</code></pre> <p>Let's define a dataframe-agnostic function in which we pass the name of a column to select that column.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(\"foo\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo\n0    1\n1    2\n2    3\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2502\n\u2502 2   \u2502\n\u2502 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2502\n\u2502 2   \u2502\n\u2502 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Multiple columns can be selected by passing a list of column names.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select([\"foo\", \"bar\"])\n&gt;&gt;&gt; func(df_pd)\n   foo  bar\n0    1    6\n1    2    7\n2    3    8\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2502\n\u2502 2   \u2506 7   \u2502\n\u2502 3   \u2506 8   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2502\n\u2502 2   \u2506 7   \u2502\n\u2502 3   \u2506 8   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Multiple columns can also be selected using positional arguments instead of a list. Expressions are also accepted.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"foo\"), nw.col(\"bar\") + 1)\n&gt;&gt;&gt; func(df_pd)\n   foo  bar\n0    1    7\n1    2    8\n2    3    9\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 7   \u2502\n\u2502 2   \u2506 8   \u2502\n\u2502 3   \u2506 9   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 7   \u2502\n\u2502 2   \u2506 8   \u2502\n\u2502 3   \u2506 9   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Use keyword arguments to easily name your expression inputs.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(threshold=nw.col(\"foo\") * 2)\n&gt;&gt;&gt; func(df_pd)\n   threshold\n0          2\n1          4\n2          6\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 threshold \u2502\n\u2502 ---       \u2502\n\u2502 i64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2         \u2502\n\u2502 4         \u2502\n\u2502 6         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 threshold \u2502\n\u2502 ---       \u2502\n\u2502 i64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2         \u2502\n\u2502 4         \u2502\n\u2502 6         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.sort","title":"<code>sort(by, *more_by, descending=False)</code>","text":"<p>Sort the LazyFrame by the given columns.</p> <p>Parameters:</p> Name Type Description Default <code>by</code> <code>str | Iterable[str]</code> <p>Column(s) to sort by. Accepts expression input. Strings are  parsed as column names.</p> required <code>*more_by</code> <code>str</code> <p>Additional columns to sort by, specified as positional        arguments.</p> <code>()</code> <code>descending</code> <code>bool | Sequence[bool]</code> <p>Sort in descending order. When sorting by multiple          columns, can be specified per column by passing a          sequence of booleans.</p> <code>False</code> <p>Examples:</p> <p>Pass a single column name to sort by that column.</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(\n...     {\n...         \"a\": [1, 2, None],\n...         \"b\": [6.0, 5.0, 4.0],\n...         \"c\": [\"a\", \"c\", \"b\"],\n...     }\n... )\n&gt;&gt;&gt; lf = nw.LazyFrame(lf_pl)\n&gt;&gt;&gt; lframe = lf.sort(\"a\").collect()\n&gt;&gt;&gt; lframe\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame                            |\n| Use `narwhals.to_native` to see native output |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; nw.to_native(lframe)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b   \u2506 c   \u2502\n\u2502 ---  \u2506 --- \u2506 --- \u2502\n\u2502 i64  \u2506 f64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 null \u2506 4.0 \u2506 b   \u2502\n\u2502 1    \u2506 6.0 \u2506 a   \u2502\n\u2502 2    \u2506 5.0 \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Sort by multiple columns by passing a list of columns.</p> <pre><code>&gt;&gt;&gt; lframe = lf.sort([\"c\", \"a\"], descending=True).collect()\n&gt;&gt;&gt; lframe\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame                            |\n| Use `narwhals.to_native` to see native output |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; nw.to_native(lframe)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b   \u2506 c   \u2502\n\u2502 ---  \u2506 --- \u2506 --- \u2502\n\u2502 i64  \u2506 f64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2    \u2506 5.0 \u2506 c   \u2502\n\u2502 null \u2506 4.0 \u2506 b   \u2502\n\u2502 1    \u2506 6.0 \u2506 a   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Or use positional arguments to sort by multiple columns in the same way.</p> <pre><code>&gt;&gt;&gt; lframe = lf.sort(\"c\", \"a\", descending=[False, True]).collect()\n&gt;&gt;&gt; lframe\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame                            |\n| Use `narwhals.to_native` to see native output |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; nw.to_native(lframe)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b   \u2506 c   \u2502\n\u2502 ---  \u2506 --- \u2506 --- \u2502\n\u2502 i64  \u2506 f64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 6.0 \u2506 a   \u2502\n\u2502 null \u2506 4.0 \u2506 b   \u2502\n\u2502 2    \u2506 5.0 \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.tail","title":"<code>tail(n=5)</code>","text":"<p>Get the last <code>n</code> rows.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of rows to return.</p> <code>5</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\n...     \"a\": [1, 2, 3, 4, 5, 6],\n...     \"b\": [7, 8, 9, 10, 11, 12],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function that gets the last 3 rows.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.tail(3)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a   b\n3  4  10\n4  5  11\n5  6  12\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 4   \u2506 10  \u2502\n\u2502 5   \u2506 11  \u2502\n\u2502 6   \u2506 12  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 4   \u2506 10  \u2502\n\u2502 5   \u2506 11  \u2502\n\u2502 6   \u2506 12  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.unique","title":"<code>unique(subset)</code>","text":"<p>Drop duplicate rows from this LazyFrame.</p> <p>Parameters:</p> Name Type Description Default <code>subset</code> <code>str | list[str]</code> <p>Column name(s) to consider when identifying duplicate rows.      If set to <code>None</code>, use all columns.</p> required <p>Returns:</p> Name Type Description <code>LazyFrame</code> <code>Self</code> <p>LazyFrame with unique rows.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(\n...     {\n...         \"foo\": [1, 2, 3, 1],\n...         \"bar\": [\"a\", \"a\", \"a\", \"a\"],\n...         \"ham\": [\"b\", \"b\", \"b\", \"b\"],\n...     }\n... )\n&gt;&gt;&gt; lf = nw.LazyFrame(lf_pl)\n&gt;&gt;&gt; lframe = lf.unique(None).collect().sort(\"foo\")\n&gt;&gt;&gt; lframe\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame                            |\n| Use `narwhals.to_native` to see native output |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; nw.to_native(lframe)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 str \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 a   \u2506 b   \u2502\n\u2502 2   \u2506 a   \u2506 b   \u2502\n\u2502 3   \u2506 a   \u2506 b   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; lframe = lf.unique(subset=[\"bar\", \"ham\"]).collect().sort(\"foo\")\n&gt;&gt;&gt; lframe\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame                            |\n| Use `narwhals.to_native` to see native output |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; nw.to_native(lframe)\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 str \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 a   \u2506 b   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.with_columns","title":"<code>with_columns(*exprs, **named_exprs)</code>","text":"<p>Add columns to this LazyFrame.</p> <p>Added columns will replace existing columns with the same name.</p> <p>Parameters:</p> Name Type Description Default <code>*exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Column(s) to add, specified as positional arguments.      Accepts expression input. Strings are parsed as column names, other      non-expression inputs are parsed as literals.</p> <code>()</code> <code>**named_exprs</code> <code>IntoExpr</code> <p>Additional columns to add, specified as keyword arguments.             The columns will be renamed to the keyword used.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>LazyFrame</code> <code>Self</code> <p>A new LazyFrame with the columns added.</p> Note <p>Creating a new LazyFrame using this method does not create a new copy of existing data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\n...     \"a\": [1, 2, 3, 4],\n...     \"b\": [0.5, 4, 10, 13],\n...     \"c\": [True, True, False, True],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(df)\n</code></pre> <p>Let's define a dataframe-agnostic function in which we pass an expression to add it as a new column:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns((nw.col(\"a\") * 2).alias(\"2a\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a     b      c  2a\n0  1   0.5   True   2\n1  2   4.0   True   4\n2  3  10.0  False   6\n3  4  13.0   True   8\n&gt;&gt;&gt; func(df_pl)\nshape: (4, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b    \u2506 c     \u2506 2a  \u2502\n\u2502 --- \u2506 ---  \u2506 ---   \u2506 --- \u2502\n\u2502 i64 \u2506 f64  \u2506 bool  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 0.5  \u2506 true  \u2506 2   \u2502\n\u2502 2   \u2506 4.0  \u2506 true  \u2506 4   \u2502\n\u2502 3   \u2506 10.0 \u2506 false \u2506 6   \u2502\n\u2502 4   \u2506 13.0 \u2506 true  \u2506 8   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (4, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b    \u2506 c     \u2506 2a  \u2502\n\u2502 --- \u2506 ---  \u2506 ---   \u2506 --- \u2502\n\u2502 i64 \u2506 f64  \u2506 bool  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 0.5  \u2506 true  \u2506 2   \u2502\n\u2502 2   \u2506 4.0  \u2506 true  \u2506 4   \u2502\n\u2502 3   \u2506 10.0 \u2506 false \u2506 6   \u2502\n\u2502 4   \u2506 13.0 \u2506 true  \u2506 8   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.with_row_index","title":"<code>with_row_index(name='index')</code>","text":"<p>Insert column which enumerates rows.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3], \"b\": [4, 5, 6]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.LazyFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     df = df.with_row_index()\n...     return nw.to_native(df)\n</code></pre> <p>We can then pass either pandas or Polars:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   index  a  b\n0      0  1  4\n1      1  2  5\n2      2  3  6\n&gt;&gt;&gt; func(df_pl).collect()\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 index \u2506 a   \u2506 b   \u2502\n\u2502 ---   \u2506 --- \u2506 --- \u2502\n\u2502 u32   \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0     \u2506 1   \u2506 4   \u2502\n\u2502 1     \u2506 2   \u2506 5   \u2502\n\u2502 2     \u2506 3   \u2506 6   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/","title":"<code>narwhals</code>","text":"<p>Here are the top-level functions available in Narwhals.</p>"},{"location":"api-reference/narwhals/#narwhals.all","title":"<code>all()</code>","text":"<p>Instantiate an expression representing all columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.all() * 2)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a   b\n0  2   8\n1  4  10\n2  6  12\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2506 8   \u2502\n\u2502 4   \u2506 10  \u2502\n\u2502 6   \u2506 12  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.col","title":"<code>col(*names)</code>","text":"<p>Creates an expression that references one or more columns by their name(s).</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>str | Iterable[str]</code> <p>Name(s) of the columns to use in the aggregation function.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2], \"b\": [3, 4]})\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2], \"b\": [3, 4]})\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\") * nw.col(\"b\"))\n</code></pre> <p>We can then pass either pandas or polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a\n0  3\n1  8\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 3   \u2502\n\u2502 8   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.concat","title":"<code>concat(items, *, how='vertical')</code>","text":""},{"location":"api-reference/narwhals/#narwhals.from_native","title":"<code>from_native(native_dataframe, *, strict=True, eager_only=None, series_only=None, allow_series=None)</code>","text":"<p>Convert dataframe to Narwhals DataFrame, LazyFrame, or Series.</p> <p>Parameters:</p> Name Type Description Default <code>native_dataframe</code> <code>Any</code> <p>Raw dataframe from user. Depending on the other arguments, input object can be:</p> <ul> <li>pandas.DataFrame</li> <li>polars.DataFrame</li> <li>polars.LazyFrame</li> <li>anything with a <code>__narwhals_dataframe__</code> or <code>__narwhals_lazyframe__</code> method</li> <li>pandas.Series</li> <li>polars.Series</li> <li>anything with a <code>__narwhals_series__</code> method</li> </ul> required <code>strict</code> <code>bool</code> <p>Whether to raise if object can't be converted (default) or to just leave it as-is.</p> <code>True</code> <code>eager_only</code> <code>bool | None</code> <p>Whether to only allow eager objects.</p> <code>None</code> <code>series_only</code> <code>bool | None</code> <p>Whether to only allow series.</p> <code>None</code> <code>allow_series</code> <code>bool | None</code> <p>Whether to allow series (default is only dataframe / lazyframe).</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame | LazyFrame | Series</code> <p>narwhals.DataFrame or narwhals.LazyFrame or narwhals.Series</p>"},{"location":"api-reference/narwhals/#narwhals.get_native_namespace","title":"<code>get_native_namespace(obj)</code>","text":"<p>Get native namespace from object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = nw.from_native(pd.DataFrame({\"a\": [1, 2, 3]}))\n&gt;&gt;&gt; nw.get_native_namespace(df)\n&lt;module 'pandas'...&gt;\n&gt;&gt;&gt; df = nw.from_native(pl.DataFrame({\"a\": [1, 2, 3]}))\n&gt;&gt;&gt; nw.get_native_namespace(df)\n&lt;module 'polars'...&gt;\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.len","title":"<code>len()</code>","text":"<p>Return the number of rows.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2], \"b\": [5, 10]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2], \"b\": [5, 10]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.len())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   len\n0    2\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 len \u2502\n\u2502 --- \u2502\n\u2502 u32 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.maybe_align_index","title":"<code>maybe_align_index(lhs, rhs)</code>","text":"<p>Align <code>lhs</code> to the Index of `rhs, if they're both pandas-like.</p> Notes <p>This is only really intended for backwards-compatibility purposes, for example if your library already aligns indices for users. If you're designing a new library, we highly encourage you to not rely on the Index. For non-pandas-like inputs, this only checks that <code>lhs</code> and <code>rhs</code> are the same length.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2]}, index=[3, 4])\n&gt;&gt;&gt; s_pd = pd.Series([6, 7], index=[4, 3])\n&gt;&gt;&gt; df = nw.from_native(df_pd)\n&gt;&gt;&gt; s = nw.from_native(s_pd, series_only=True)\n&gt;&gt;&gt; nw.to_native(nw.maybe_align_index(df, s))\n   a\n4  2\n3  1\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.maybe_set_index","title":"<code>maybe_set_index(df, column_names)</code>","text":"<p>Set columns <code>columns</code> to be the index of <code>df</code>, if <code>df</code> is pandas-like.</p> Notes <p>This is only really intended for backwards-compatibility purposes, for example if your library already aligns indices for users. If you're designing a new library, we highly encourage you to not rely on the Index. For non-pandas-like inputs, this is a no-op.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2], \"b\": [4, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_pd)\n&gt;&gt;&gt; nw.to_native(nw.maybe_set_index(df, \"b\"))\n   a\nb\n4  1\n5  2\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.maybe_convert_dtypes","title":"<code>maybe_convert_dtypes(df, *args, **kwargs)</code>","text":"<p>Convert columns to the best possible dtypes using dtypes supporting <code>pd.NA</code>, if df is pandas-like.</p> Notes <p>For non-pandas-like inputs, this is a no-op. Also, <code>args</code> and <code>kwargs</code> just get passed down to the underlying library as-is.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; df_pd = pd.DataFrame(\n...     {\n...         \"a\": pd.Series([1, 2, 3], dtype=np.dtype(\"int32\")),\n...         \"b\": pd.Series([True, False, np.nan], dtype=np.dtype(\"O\")),\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_pd)\n&gt;&gt;&gt; nw.to_native(nw.maybe_convert_dtypes(df)).dtypes\na             Int32\nb           boolean\ndtype: object\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.lit","title":"<code>lit(value, dtype=None)</code>","text":"<p>Return an expression representing a literal value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to use as literal.</p> required <code>dtype</code> <code>DType | None</code> <p>The data type of the literal value. If not provided, the data type will be inferred.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2]})\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2]})\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(nw.lit(3).alias(\"b\"))\n</code></pre> <p>We can then pass either pandas or polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n0  1  3\n1  2  3\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i32 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 3   \u2502\n\u2502 2   \u2506 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.max","title":"<code>max(*columns)</code>","text":"<p>Return the maximum value.</p> Note <p>Syntactic sugar for <code>nw.col(columns).max()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str</code> <p>Name(s) of the columns to use in the aggregation function.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2], \"b\": [5, 10]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2], \"b\": [5, 10]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.max(\"a\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a\n0  2\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.mean","title":"<code>mean(*columns)</code>","text":"<p>Get the mean value.</p> Note <p>Syntactic sugar for <code>nw.col(columns).mean()</code></p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str</code> <p>Name(s) of the columns to use in the aggregation function</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 8, 3]})\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 8, 3]})\n</code></pre> <p>We define a dataframe agnostic function:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     df = df.select(nw.mean(\"a\"))\n...     return nw.to_native(df)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n     a\n0  4.0\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 4.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.min","title":"<code>min(*columns)</code>","text":"<p>Return the minimum value.</p> Note <p>Syntactic sugar for <code>nw.col(columns).min()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str</code> <p>Name(s) of the columns to use in the aggregation function.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2], \"b\": [5, 10]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2], \"b\": [5, 10]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.min(\"b\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   b\n0  5\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 b   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 5   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.narwhalify","title":"<code>narwhalify(func=None, *, strict=False, eager_only=False, series_only=False, allow_series=True)</code>","text":"<p>Decorate function so it becomes dataframe-agnostic.</p> <p><code>narwhalify</code> will try to convert any dataframe/series-like object into the narwhal respective DataFrame/Series, while leaving the other parameters as they are.</p> <p>Similarly, if the output of the function is a narwhals DataFrame or Series, it will be converted back to the original dataframe/series type, while if the output is another type it will be left as is.</p> <p>By setting <code>strict=True</code>, then every input and every output will be required to be a dataframe/series-like object.</p> <p>Instead of writing</p> <pre><code>import narwhals as nw\n\n\ndef func(df_any):\n    df = nw.from_native(df_any, strict=False)\n    df = df.group_by(\"a\").agg(nw.col(\"b\").sum())\n    return nw.to_native(df)\n</code></pre> <p>you can just write</p> <pre><code>import narwhals as nw\n\n\n@nw.narwhalify\ndef func(df):\n    return df.group_by(\"a\").agg(nw.col(\"b\").sum())\n</code></pre> <p>You can also pass in extra arguments, e.g.</p> <pre><code>@nw.narhwalify(eager_only=True)\n</code></pre> <p>that will get passed down to <code>nw.from_native</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any] | None</code> <p>Function to wrap in a <code>from_native</code>-<code>to_native</code> block.</p> <code>None</code> <code>strict</code> <code>bool</code> <p>Whether to raise if object can't be converted or to just leave it as-is (default).</p> <code>False</code> <code>eager_only</code> <code>bool | None</code> <p>Whether to only allow eager objects.</p> <code>False</code> <code>series_only</code> <code>bool | None</code> <p>Whether to only allow series.</p> <code>False</code> <code>allow_series</code> <code>bool | None</code> <p>Whether to allow series (default is only dataframe / lazyframe).</p> <code>True</code>"},{"location":"api-reference/narwhals/#narwhals.sum","title":"<code>sum(*columns)</code>","text":"<p>Sum all values.</p> Note <p>Syntactic sugar for <code>nw.col(columns).sum()</code></p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str</code> <p>Name(s) of the columns to use in the aggregation function</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2]})\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2]})\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.sum(\"a\"))\n</code></pre> <p>We can then pass either pandas or polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a\n0  3\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.sum_horizontal","title":"<code>sum_horizontal(*exprs)</code>","text":"<p>Sum all values horizontally across columns</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Name(s) of the columns to use in the aggregation function. Accepts expression input.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2, 3], \"b\": [5, 10, 15]})\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [5, 10, 15]})\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.sum_horizontal(\"a\", \"b\"))\n</code></pre> <p>We can then pass either pandas or polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n    a\n0   6\n1  12\n2  18\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 6   \u2502\n\u2502 12  \u2502\n\u2502 18  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.show_versions","title":"<code>show_versions()</code>","text":"<p>Print useful debugging information</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from narwhals import show_versions\n&gt;&gt;&gt; show_versions()  # doctest:+SKIP\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.to_native","title":"<code>to_native(narwhals_object, *, strict=True)</code>","text":"<p>Convert Narwhals object to native one.</p> <p>Parameters:</p> Name Type Description Default <code>narwhals_object</code> <code>LazyFrame | DataFrame | Series</code> <p>Narwhals object.</p> required <code>strict</code> <code>bool</code> <p>whether to raise on non-Narwhals input.</p> <code>True</code> <p>Returns:</p> Type Description <code>Any</code> <p>Object of class that user started with.</p>"},{"location":"api-reference/selectors/","title":"<code>narwhals.selectors</code>","text":"<p>The following selectors are all supported. In addition, just like in Polars, the following set operations are supported:</p> <ul> <li>set intersection: <code>&amp;</code></li> <li>set union: <code>|</code></li> <li>set difference: <code>-</code></li> <li>complement: <code>~</code></li> </ul>"},{"location":"api-reference/selectors/#narwhals.selectors.boolean","title":"<code>boolean()</code>","text":"<p>Select boolean columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\"a\": [1, 2], \"b\": [\"x\", \"y\"], \"c\": [False, True]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function to select boolean dtypes:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     df = df.select(ncs.boolean())\n...     return nw.to_native(df)\n</code></pre> <p>We can then pass either pandas or Polars dataframes:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n       c\n0  False\n1   True\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 c     \u2502\n\u2502 ---   \u2502\n\u2502 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 false \u2502\n\u2502 true  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/selectors/#narwhals.selectors.by_dtype","title":"<code>by_dtype(*dtypes)</code>","text":"<p>Select columns based on their dtype.</p> <p>Parameters:</p> Name Type Description Default <code>dtypes</code> <code>Any</code> <p>one or data types to select</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\"a\": [1, 2], \"b\": [\"x\", \"y\"], \"c\": [4.1, 2.3]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function to select int64 and float64 dtypes and multiplies each value by 2:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     df = df.select(ncs.by_dtype(nw.Int64, nw.Float64) * 2)\n...     return nw.to_native(df)\n</code></pre> <p>We can then pass either pandas or Polars dataframes:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a    c\n0  2  8.2\n1  4  4.6\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2506 8.2 \u2502\n\u2502 4   \u2506 4.6 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/selectors/#narwhals.selectors.categorical","title":"<code>categorical()</code>","text":"<p>Select categorical columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\"a\": [1, 2], \"b\": [\"x\", \"y\"], \"c\": [False, True]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data).astype({\"b\": \"category\"})\n&gt;&gt;&gt; df_pl = pl.DataFrame(data, schema_overrides={\"b\": pl.Categorical})\n</code></pre> <p>Let's define a dataframe-agnostic function to select string dtypes:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     df = df.select(ncs.categorical())\n...     return nw.to_native(df)\n</code></pre> <p>We can then pass either pandas or Polars dataframes:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   b\n0  x\n1  y\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 b   \u2502\n\u2502 --- \u2502\n\u2502 cat \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 x   \u2502\n\u2502 y   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/selectors/#narwhals.selectors.numeric","title":"<code>numeric()</code>","text":"<p>Select numeric columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\"a\": [1, 2], \"b\": [\"x\", \"y\"], \"c\": [4.1, 2.3]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function to select numeric dtypes and multiplies each value by 2:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     df = df.select(ncs.numeric() * 2)\n...     return nw.to_native(df)\n</code></pre> <p>We can then pass either pandas or Polars dataframes:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a    c\n0  2  8.2\n1  4  4.6\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2506 8.2 \u2502\n\u2502 4   \u2506 4.6 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/selectors/#narwhals.selectors.string","title":"<code>string()</code>","text":"<p>Select string columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\"a\": [1, 2], \"b\": [\"x\", \"y\"], \"c\": [False, True]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function to select string dtypes:</p> <pre><code>&gt;&gt;&gt; def func(df_any):\n...     df = nw.from_native(df_any)\n...     df = df.select(ncs.string())\n...     return nw.to_native(df)\n</code></pre> <p>We can then pass either pandas or Polars dataframes:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   b\n0  x\n1  y\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 b   \u2502\n\u2502 --- \u2502\n\u2502 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 x   \u2502\n\u2502 y   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/series/","title":"<code>narwhals.Series</code>","text":""},{"location":"api-reference/series/#narwhals.series.Series.dtype","title":"<code>dtype: Any</code>  <code>property</code>","text":"<p>Get the data type of the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.dtype\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\nInt64\n&gt;&gt;&gt; func(s_pl)\nInt64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Get the name of the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s, name=\"foo\")\n&gt;&gt;&gt; s_pl = pl.Series(\"foo\", s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.name\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n'foo'\n&gt;&gt;&gt; func(s_pl)\n'foo'\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.shape","title":"<code>shape: tuple[int]</code>  <code>property</code>","text":"<p>Get the shape of the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.shape\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n(3,)\n&gt;&gt;&gt; func(s_pl)\n(3,)\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.alias","title":"<code>alias(name)</code>","text":"<p>Rename the Series.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The new name.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s, name=\"foo\")\n&gt;&gt;&gt; s_pl = pl.Series(\"foo\", s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.alias(\"bar\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    1\n1    2\n2    3\nName: bar, dtype: int64\n&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: 'bar' [i64]\n[\n   1\n   2\n   3\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.all","title":"<code>all()</code>","text":"<p>Return whether all values in the Series are True.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [True, False, True]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.all()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\nFalse\n&gt;&gt;&gt; func(s_pl)\nFalse\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.any","title":"<code>any()</code>","text":"<p>Return whether any of the values in the Series are True.</p> Notes <p>Only works on Series of data type Boolean.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [False, True, False]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.any()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\nTrue\n&gt;&gt;&gt; func(s_pl)\nTrue\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.cast","title":"<code>cast(dtype)</code>","text":"<p>Cast between data types.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>Any</code> <p>Data type that the object will be cast into.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [True, False, True]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.cast(nw.Int64)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    1\n1    0\n2    1\ndtype: int64\n&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [i64]\n[\n   1\n   0\n   1\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.cum_sum","title":"<code>cum_sum()</code>","text":"<p>Calculate the cumulative sum.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [2, 4, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.cum_sum()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    2\n1    6\n2    9\ndtype: int64\n&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [i64]\n[\n   2\n   6\n   9\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.diff","title":"<code>diff()</code>","text":"<p>Calculate the difference with the previous element, for each element.</p> Notes <p>pandas may change the dtype here, for example when introducing missing values in an integer column. To ensure, that the dtype doesn't change, you may want to use <code>fill_null</code> and <code>cast</code>. For example, to calculate the diff and fill missing values with <code>0</code> in a Int64 column, you could do:</p> <p>```python</p> <p>s_any.diff().fill_null(0).cast(nw.Int64)     ```</p> <p>Examples:     &gt;&gt;&gt; import pandas as pd     &gt;&gt;&gt; import polars as pl     &gt;&gt;&gt; import narwhals as nw     &gt;&gt;&gt; s = [2, 4, 3]     &gt;&gt;&gt; s_pd = pd.Series(s)     &gt;&gt;&gt; s_pl = pl.Series(s)</p> <pre><code>We define a dataframe-agnostic function:\n\n&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.diff()\n\nWe can then pass either pandas or Polars to `func`:\n\n&gt;&gt;&gt; func(s_pd)\n0    NaN\n1    2.0\n2   -1.0\ndtype: float64\n&gt;&gt;&gt; func(s_pl)  # doctest: +NORMALIZE_WHITESPACE\nshape: (3,)\nSeries: '' [i64]\n[\n   null\n   2\n   -1\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.drop_nulls","title":"<code>drop_nulls()</code>","text":"<p>Drop all null values.</p> See Also <p>drop_nans</p> Notes <p>A null value is not the same as a NaN value. To drop NaN values, use :func:<code>drop_nans</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_pd = pd.Series([2, 4, None, 3, 5])\n&gt;&gt;&gt; s_pl = pl.Series(\"a\", [2, 4, None, 3, 5])\n</code></pre> <p>Now define a dataframe-agnostic function with a <code>column</code> argument for the column to evaluate :</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.drop_nulls()\n</code></pre> <p>Then we can pass either Series (polars or pandas) to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    2.0\n1    4.0\n3    3.0\n4    5.0\ndtype: float64\n&gt;&gt;&gt; func(s_pl)\nshape: (4,)\nSeries: 'a' [i64]\n[\n   2\n   4\n   3\n   5\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.fill_null","title":"<code>fill_null(value)</code>","text":"<p>Fill null values using the specified value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Value used to fill null values.</p> required Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, None]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.fill_null(5)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    1.0\n1    2.0\n2    5.0\ndtype: float64\n&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [i64]\n[\n   1\n   2\n   5\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.filter","title":"<code>filter(other)</code>","text":"<p>Filter elements in the Series based on a condition.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [4, 10, 15, 34, 50]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.filter(s_any &gt; 10)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n2    15\n3    34\n4    50\ndtype: int64\n&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [i64]\n[\n   15\n   34\n   50\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.head","title":"<code>head(n=10)</code>","text":"<p>Get the first <code>n</code> rows.</p> <p>Arguments     n : int         Number of rows to return.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = list(range(10))\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>Let's define a dataframe-agnostic function that returns the first 3 rows:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.head(3)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    0\n1    1\n2    2\ndtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [i64]\n[\n   0\n   1\n   2\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_between","title":"<code>is_between(lower_bound, upper_bound, closed='both')</code>","text":"<p>Get a boolean mask of the values that are between the given lower/upper bounds.</p> <p>Parameters:</p> Name Type Description Default <code>lower_bound</code> <code>Any</code> <p>Lower bound value.</p> required <code>upper_bound</code> <code>Any</code> <p>Upper bound value.</p> required <code>closed</code> <code>str</code> <p>Define which sides of the interval are closed (inclusive).</p> <code>'both'</code> Notes <p>If the value of the <code>lower_bound</code> is greater than that of the <code>upper_bound</code>, then the values will be False, as no value can satisfy the condition.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_pd = pd.Series([1, 2, 3, 4, 5])\n&gt;&gt;&gt; s_pl = pl.Series([1, 2, 3, 4, 5])\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.is_between(2, 4, \"right\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    False\n1    False\n2     True\n3     True\n4    False\ndtype: bool\n&gt;&gt;&gt; func(s_pl)\nshape: (5,)\nSeries: '' [bool]\n[\n   false\n   false\n   true\n   true\n   false\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_duplicated","title":"<code>is_duplicated()</code>","text":"<p>Get a mask of all duplicated rows in the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; s_pd = pd.Series([1, 2, 3, 1])\n&gt;&gt;&gt; s_pl = pl.Series([1, 2, 3, 1])\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.is_duplicated()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0     True\n1    False\n2    False\n3     True\ndtype: bool\n&gt;&gt;&gt; func(s_pl)\nshape: (4,)\nSeries: '' [bool]\n[\n    true\n    false\n    false\n    true\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_empty","title":"<code>is_empty()</code>","text":"<p>Check if the series is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n</code></pre> <p>Let's define a dataframe-agnostic function that filters rows in which \"foo\" values are greater than 10, and then checks if the result is empty or not:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.filter(s_any &gt; 10).is_empty()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; s_pd = pd.Series([1, 2, 3])\n&gt;&gt;&gt; s_pl = pl.Series([1, 2, 3])\n&gt;&gt;&gt; func(s_pd), func(s_pl)\n(True, True)\n</code></pre> <pre><code>&gt;&gt;&gt; s_pd = pd.Series([100, 2, 3])\n&gt;&gt;&gt; s_pl = pl.Series([100, 2, 3])\n&gt;&gt;&gt; func(s_pd), func(s_pl)\n(False, False)\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_first_distinct","title":"<code>is_first_distinct()</code>","text":"<p>Return a boolean mask indicating the first occurrence of each distinct value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; s_pd = pd.Series([1, 1, 2, 3, 2])\n&gt;&gt;&gt; s_pl = pl.Series([1, 1, 2, 3, 2])\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.is_first_distinct()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0     True\n1    False\n2     True\n3     True\n4    False\ndtype: bool\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (5,)\nSeries: '' [bool]\n[\n    true\n    false\n    true\n    true\n    false\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_in","title":"<code>is_in(other)</code>","text":"<p>Check if the elements of this Series are in the other sequence.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>Sequence of primitive type.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_pd = pd.Series([1, 2, 3])\n&gt;&gt;&gt; s_pl = pl.Series([1, 2, 3])\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.is_in([3, 2, 8])\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    False\n1     True\n2     True\ndtype: bool\n&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [bool]\n[\n   false\n   true\n   true\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_last_distinct","title":"<code>is_last_distinct()</code>","text":"<p>Return a boolean mask indicating the last occurrence of each distinct value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; s_pd = pd.Series([1, 1, 2, 3, 2])\n&gt;&gt;&gt; s_pl = pl.Series([1, 1, 2, 3, 2])\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.is_last_distinct()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    False\n1     True\n2    False\n3     True\n4     True\ndtype: bool\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (5,)\nSeries: '' [bool]\n[\n    false\n    true\n    false\n    true\n    true\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_null","title":"<code>is_null()</code>","text":"<p>Returns a boolean Series indicating which values are null.</p> Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, None]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.is_null()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    False\n1    False\n2     True\ndtype: bool\n&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [bool]\n[\n   false\n   false\n   true\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_sorted","title":"<code>is_sorted(*, descending=False)</code>","text":"<p>Check if the Series is sorted.</p> <p>Parameters:</p> Name Type Description Default <code>descending</code> <code>bool</code> <p>Check if the Series is sorted in descending order.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; unsorted_data = [1, 3, 2]\n&gt;&gt;&gt; sorted_data = [3, 2, 1]\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any, descending=False):\n...     return s_any.is_sorted(descending=descending)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(pl.Series(unsorted_data))\nFalse\n&gt;&gt;&gt; func(pl.Series(sorted_data), descending=True)\nTrue\n&gt;&gt;&gt; func(pd.Series(unsorted_data))\nFalse\n&gt;&gt;&gt; func(pd.Series(sorted_data), descending=True)\nTrue\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_unique","title":"<code>is_unique()</code>","text":"<p>Get a mask of all unique rows in the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; s_pd = pd.Series([1, 2, 3, 1])\n&gt;&gt;&gt; s_pl = pl.Series([1, 2, 3, 1])\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.is_unique()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    False\n1     True\n2     True\n3    False\ndtype: bool\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (4,)\nSeries: '' [bool]\n[\n    false\n     true\n     true\n    false\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.item","title":"<code>item(index=None)</code>","text":"<p>Return the Series as a scalar, or return the element at the given index.</p> <p>If no index is provided, this is equivalent to <code>s[0]</code>, with a check that the shape is (1,). With an index, this is equivalent to <code>s[index]</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n</code></pre> <p>Let's define a dataframe-agnostic function that returns item at given index</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any, index=None):\n...     return s_any.item(index)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(pl.Series(\"a\", [1]), None), func(pd.Series([1]), None)\n(1, 1)\n</code></pre> <pre><code>&gt;&gt;&gt; func(pl.Series(\"a\", [9, 8, 7]), -1), func(pl.Series([9, 8, 7]), -2)\n(7, 8)\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.len","title":"<code>len()</code>","text":"<p>Return the number of elements in the Series.</p> <p>Null values count towards the total.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = [1, 2, None]\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>Let's define a dataframe-agnostic function that computes the len of the series:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.len()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n3\n&gt;&gt;&gt; func(s_pl)\n3\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.max","title":"<code>max()</code>","text":"<p>Get the maximum value in this Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.max()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n3\n&gt;&gt;&gt; func(s_pl)\n3\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.mean","title":"<code>mean()</code>","text":"<p>Reduce this Series to the mean value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.mean()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n2.0\n&gt;&gt;&gt; func(s_pl)\n2.0\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.min","title":"<code>min()</code>","text":"<p>Get the minimal value in this Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.min()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n1\n&gt;&gt;&gt; func(s_pl)\n1\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.null_count","title":"<code>null_count()</code>","text":"<p>Create a new Series that shows the null counts per column.</p> Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; s_pd = pd.Series([1, None, 3])\n&gt;&gt;&gt; s_pl = pl.Series([1, None, None])\n</code></pre> <p>Let's define a dataframe-agnostic function that returns the null count of the series:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.null_count()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n1\n&gt;&gt;&gt; func(s_pl)\n2\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.n_unique","title":"<code>n_unique()</code>","text":"<p>Count the number of unique values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.n_unique()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n3\n&gt;&gt;&gt; func(s_pl)\n3\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.quantile","title":"<code>quantile(quantile, interpolation)</code>","text":"<p>Get quantile value of the series.</p> Note <p>pandas and Polars may have implementation differences for a given interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>quantile</code> <p>float Quantile between 0.0 and 1.0.</p> required <code>interpolation</code> <p>{'nearest', 'higher', 'lower', 'midpoint', 'linear'} Interpolation method.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = list(range(50))\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return [\n...         s_any.quantile(quantile=q, interpolation=\"nearest\")\n...         for q in (0.1, 0.25, 0.5, 0.75, 0.9)\n...     ]\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n[5, 12, 24, 37, 44]\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\n[5.0, 12.0, 25.0, 37.0, 44.0]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.round","title":"<code>round(decimals=0)</code>","text":"<p>Round underlying floating point data by <code>decimals</code> digits.</p> <p>Arguments     decimals: Number of decimals to round by.</p> Notes <p>For values exactly halfway between rounded decimal values pandas and Polars behave differently.</p> <p>pandas rounds to the nearest even value (e.g. -0.5 and 0.5 round to 0.0, 1.5 and 2.5 round to 2.0, 3.5 and 4.5 to 4.0, etc..).</p> <p>Polars rounds away from 0 (e.g. -0.5 to -1.0, 0.5 to 1.0, 1.5 to 2.0, 2.5 to 3.0, etc..).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = [1.12345, 2.56789, 3.901234]\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>Let's define a dataframe-agnostic function that rounds to the first decimal:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.round(1)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    1.1\n1    2.6\n2    3.9\ndtype: float64\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [f64]\n[\n   1.1\n   2.6\n   3.9\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.sample","title":"<code>sample(n=None, fraction=None, *, with_replacement=False)</code>","text":"<p>Sample randomly from this Series.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | None</code> <p>Number of items to return. Cannot be used with fraction.</p> <code>None</code> <code>fraction</code> <code>float | None</code> <p>Fraction of items to return. Cannot be used with n.</p> <code>None</code> <code>with_replacement</code> <code>bool</code> <p>Allow values to be sampled more than once.</p> <code>False</code> Notes <p>The <code>sample</code> method returns a Series with a specified number of randomly selected items chosen from this Series. The results are not consistent across libraries.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n</code></pre> <pre><code>&gt;&gt;&gt; s_pd = pd.Series([1, 2, 3, 4])\n&gt;&gt;&gt; s_pl = pl.Series([1, 2, 3, 4])\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.sample(fraction=1.0, with_replacement=True)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n   a\n2  3\n1  2\n3  4\n3  4\n&gt;&gt;&gt; func(s_pl)\nshape: (4,)\nSeries: '' [i64]\n[\n   1\n   4\n   3\n   4\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.shift","title":"<code>shift(n)</code>","text":"<p>Shift values by <code>n</code> positions.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of indices to shift forward. If a negative value is passed, values are shifted in the opposite direction instead.</p> required Notes <p>pandas may change the dtype here, for example when introducing missing values in an integer column. To ensure, that the dtype doesn't change, you may want to use <code>fill_null</code> and <code>cast</code>. For example, to shift and fill missing values with <code>0</code> in a Int64 column, you could do:</p> <p>```python</p> <p>s_any.shift(1).fill_null(0).cast(nw.Int64)     ```</p> <p>Examples:     &gt;&gt;&gt; import pandas as pd     &gt;&gt;&gt; import polars as pl     &gt;&gt;&gt; import narwhals as nw     &gt;&gt;&gt; s = [2, 4, 3]     &gt;&gt;&gt; s_pd = pd.Series(s)     &gt;&gt;&gt; s_pl = pl.Series(s)</p> <pre><code>We define a dataframe-agnostic function:\n\n&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.shift(1)\n\nWe can then pass either pandas or Polars to `func`:\n\n&gt;&gt;&gt; func(s_pd)\n0    NaN\n1    2.0\n2    4.0\ndtype: float64\n&gt;&gt;&gt; func(s_pl)  # doctest: +NORMALIZE_WHITESPACE\nshape: (3,)\nSeries: '' [i64]\n[\n   null\n   2\n   4\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.sort","title":"<code>sort(*, descending=False)</code>","text":"<p>Sort this Series. Place null values first.</p> <p>Parameters:</p> Name Type Description Default <code>descending</code> <code>bool</code> <p>Sort in descending order.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [5, None, 1, 2]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define library agnostic functions:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.sort()\n</code></pre> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func_descend(s_any):\n...     return s_any.sort(descending=True)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n1    NaN\n2    1.0\n3    2.0\n0    5.0\ndtype: float64\n&gt;&gt;&gt; func(s_pl)\nshape: (4,)\nSeries: '' [i64]\n[\n   null\n   1\n   2\n   5\n]\n&gt;&gt;&gt; func_descend(s_pd)\n1    NaN\n0    5.0\n3    2.0\n2    1.0\ndtype: float64\n&gt;&gt;&gt; func_descend(s_pl)\nshape: (4,)\nSeries: '' [i64]\n[\n   null\n   5\n   2\n   1\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.std","title":"<code>std(*, ddof=1)</code>","text":"<p>Get the standard deviation of this Series.</p> <p>Parameters:</p> Name Type Description Default <code>ddof</code> <code>int</code> <p>\u201cDelta Degrees of Freedom\u201d: the divisor used in the calculation is N - ddof,      where N represents the number of elements.</p> <code>1</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.std()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n1.0\n&gt;&gt;&gt; func(s_pl)\n1.0\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.sum","title":"<code>sum()</code>","text":"<p>Reduce this Series to the sum value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.sum()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n6\n&gt;&gt;&gt; func(s_pl)\n6\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.tail","title":"<code>tail(n=10)</code>","text":"<p>Get the last <code>n</code> rows.</p> <p>Arguments     n : int         Number of rows to return.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = list(range(10))\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>Let's define a dataframe-agnostic function that returns the last 3 rows:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.tail(3)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n7    7\n8    8\n9    9\ndtype: int64\n&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [i64]\n[\n   7\n   8\n   9\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_frame","title":"<code>to_frame()</code>","text":"<p>Convert to dataframe.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s, name=\"a\")\n&gt;&gt;&gt; s_pl = pl.Series(\"a\", s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.to_frame()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n   a\n0  1\n1  2\n2  3\n&gt;&gt;&gt; func(s_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2502\n\u2502 2   \u2502\n\u2502 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_list","title":"<code>to_list()</code>","text":"<p>Convert to list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s, name=\"a\")\n&gt;&gt;&gt; s_pl = pl.Series(\"a\", s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.to_list()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n[1, 2, 3]\n&gt;&gt;&gt; func(s_pl)\n[1, 2, 3]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_numpy","title":"<code>to_numpy()</code>","text":"<p>Convert to numpy.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s, name=\"a\")\n&gt;&gt;&gt; s_pl = pl.Series(\"a\", s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.to_numpy()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\narray([1, 2, 3]...)\n&gt;&gt;&gt; func(s_pl)\narray([1, 2, 3]...)\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_pandas","title":"<code>to_pandas()</code>","text":"<p>Convert to pandas.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s, name=\"a\")\n&gt;&gt;&gt; s_pl = pl.Series(\"a\", s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.to_pandas()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    1\n1    2\n2    3\nName: a, dtype: int64\n&gt;&gt;&gt; func(s_pl)\n0    1\n1    2\n2    3\nName: a, dtype: int64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.unique","title":"<code>unique()</code>","text":"<p>Returns unique values</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [2, 4, 4, 6]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.unique()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    2\n1    4\n2    6\ndtype: int64\n&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [i64]\n[\n   2\n   4\n   6\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.value_counts","title":"<code>value_counts(*, sort=False, parallel=False)</code>","text":"<p>Count the occurrences of unique values.</p> <p>Parameters:</p> Name Type Description Default <code>sort</code> <code>bool</code> <p>Sort the output by count in descending order. If set to False (default), the order of the output is random.</p> <code>False</code> <code>parallel</code> <code>bool</code> <p>Execute the computation in parallel. Unused for pandas-like APIs.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; s_pd = pd.Series([1, 1, 2, 3, 2], name=\"s\")\n&gt;&gt;&gt; s_pl = pl.Series(values=[1, 1, 2, 3, 2], name=\"s\")\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.value_counts(sort=True)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n   s  count\n0  1      2\n1  2      2\n2  3      1\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 s   \u2506 count \u2502\n\u2502 --- \u2506 ---   \u2502\n\u2502 i64 \u2506 u32   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 2     \u2502\n\u2502 2   \u2506 2     \u2502\n\u2502 3   \u2506 1     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.zip_with","title":"<code>zip_with(mask, other)</code>","text":"<p>Take values from self or other based on the given mask. Where mask evaluates true, take values from self. Where mask evaluates false, take values from other.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; s1_pl = pl.Series([1, 2, 3, 4, 5])\n&gt;&gt;&gt; s2_pl = pl.Series([5, 4, 3, 2, 1])\n&gt;&gt;&gt; mask_pl = pl.Series([True, False, True, False, True])\n&gt;&gt;&gt; s1_pd = pd.Series([1, 2, 3, 4, 5])\n&gt;&gt;&gt; s2_pd = pd.Series([5, 4, 3, 2, 1])\n&gt;&gt;&gt; mask_pd = pd.Series([True, False, True, False, True])\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s1_any, mask_any, s2_any):\n...     return s1_any.zip_with(mask_any, s2_any)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s1_pl, mask_pl, s2_pl)\nshape: (5,)\nSeries: '' [i64]\n[\n   1\n   4\n   3\n   2\n   5\n]\n&gt;&gt;&gt; func(s1_pd, mask_pd, s2_pd)\n0    1\n1    4\n2    3\n3    2\n4    5\ndtype: int64\n</code></pre>"},{"location":"api-reference/series_cat/","title":"<code>narwhals.Series.cat</code>","text":""},{"location":"api-reference/series_dt/","title":"<code>narwhals.Series.dt</code>","text":""},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.year","title":"<code>year()</code>","text":"<p>Get the year in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; dates = [datetime(2012, 1, 7), datetime(2023, 3, 10)]\n&gt;&gt;&gt; s_pd = pd.Series(dates)\n&gt;&gt;&gt; s_pl = pl.Series(dates)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.dt.year()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    2012\n1    2023\ndtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i32]\n[\n   2012\n   2023\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.month","title":"<code>month()</code>","text":"<p>Gets the month in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; dates = [datetime(2023, 2, 1), datetime(2023, 8, 3)]\n&gt;&gt;&gt; s_pd = pd.Series(dates)\n&gt;&gt;&gt; s_pl = pl.Series(dates)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.dt.month()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    2\n1    8\ndtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i8]\n[\n   2\n   8\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.day","title":"<code>day()</code>","text":"<p>Extracts the day in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; dates = [datetime(2022, 1, 1), datetime(2022, 1, 5)]\n&gt;&gt;&gt; s_pd = pd.Series(dates)\n&gt;&gt;&gt; s_pl = pl.Series(dates)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.dt.day()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    1\n1    5\ndtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i8]\n[\n   1\n   5\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.ordinal_day","title":"<code>ordinal_day()</code>","text":"<p>Get ordinal day.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [datetime(2020, 1, 1), datetime(2020, 8, 3)]\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.dt.ordinal_day()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0      1\n1    216\ndtype: int32\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i16]\n[\n   1\n   216\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.hour","title":"<code>hour()</code>","text":"<p>Extracts the hour in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; dates = [datetime(2022, 1, 1, 5, 3), datetime(2022, 1, 5, 9, 12)]\n&gt;&gt;&gt; s_pd = pd.Series(dates)\n&gt;&gt;&gt; s_pl = pl.Series(dates)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.dt.hour()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    5\n1    9\ndtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i8]\n[\n   5\n   9\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.minute","title":"<code>minute()</code>","text":"<p>Extracts the minute in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; dates = [datetime(2022, 1, 1, 5, 3), datetime(2022, 1, 5, 9, 12)]\n&gt;&gt;&gt; s_pd = pd.Series(dates)\n&gt;&gt;&gt; s_pl = pl.Series(dates)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.dt.minute()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0     3\n1    12\ndtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i8]\n[\n   3\n   12\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.second","title":"<code>second()</code>","text":"<p>Extracts the second(s) in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; dates = [datetime(2022, 1, 1, 5, 3, 10), datetime(2022, 1, 5, 9, 12, 4)]\n&gt;&gt;&gt; s_pd = pd.Series(dates)\n&gt;&gt;&gt; s_pl = pl.Series(dates)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.dt.second()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    10\n1     4\ndtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i8]\n[\n   10\n    4\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.millisecond","title":"<code>millisecond()</code>","text":"<p>Extracts the milliseconds in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; dates = [\n...     datetime(2023, 5, 21, 12, 55, 10, 400000),\n...     datetime(2023, 5, 21, 12, 55, 10, 600000),\n...     datetime(2023, 5, 21, 12, 55, 10, 800000),\n...     datetime(2023, 5, 21, 12, 55, 11, 0),\n...     datetime(2023, 5, 21, 12, 55, 11, 200000),\n... ]\n</code></pre> <pre><code>&gt;&gt;&gt; s_pd = pd.Series(dates)\n&gt;&gt;&gt; s_pl = pl.Series(dates)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.dt.millisecond().alias(\"datetime\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    400\n1    600\n2    800\n3      0\n4    200\nName: datetime, dtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (5,)\nSeries: 'datetime' [i32]\n[\n    400\n    600\n    800\n    0\n    200\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.microsecond","title":"<code>microsecond()</code>","text":"<p>Extracts the microseconds in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; dates = [\n...     datetime(2023, 5, 21, 12, 55, 10, 400000),\n...     datetime(2023, 5, 21, 12, 55, 10, 600000),\n...     datetime(2023, 5, 21, 12, 55, 10, 800000),\n...     datetime(2023, 5, 21, 12, 55, 11, 0),\n...     datetime(2023, 5, 21, 12, 55, 11, 200000),\n... ]\n</code></pre> <pre><code>&gt;&gt;&gt; s_pd = pd.Series(dates)\n&gt;&gt;&gt; s_pl = pl.Series(dates)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.dt.microsecond().alias(\"datetime\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    400000\n1    600000\n2    800000\n3         0\n4    200000\nName: datetime, dtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (5,)\nSeries: 'datetime' [i32]\n[\n   400000\n   600000\n   800000\n   0\n   200000\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.nanosecond","title":"<code>nanosecond()</code>","text":"<p>Extracts the nanosecond(s) in a date series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; dates = [\n...     datetime(2022, 1, 1, 5, 3, 10, 500000),\n...     datetime(2022, 1, 5, 9, 12, 4, 60000),\n... ]\n&gt;&gt;&gt; s_pd = pd.Series(dates)\n&gt;&gt;&gt; s_pl = pl.Series(dates)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.dt.nanosecond()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    500000000\n1     60000000\ndtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i32]\n[\n   500000000\n   60000000\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.total_minutes","title":"<code>total_minutes()</code>","text":"<p>Get total minutes.</p> Notes <p>The function outputs the total minutes in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [timedelta(minutes=10), timedelta(minutes=20, seconds=40)]\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.dt.total_minutes()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    10\n1    20\ndtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i64]\n[\n        10\n        20\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.total_seconds","title":"<code>total_seconds()</code>","text":"<p>Get total seconds.</p> Notes <p>The function outputs the total seconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [timedelta(seconds=10), timedelta(seconds=20, milliseconds=40)]\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.dt.total_seconds()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    10\n1    20\ndtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i64]\n[\n        10\n        20\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.total_milliseconds","title":"<code>total_milliseconds()</code>","text":"<p>Get total milliseconds.</p> Notes <p>The function outputs the total milliseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [\n...     timedelta(milliseconds=10),\n...     timedelta(milliseconds=20, microseconds=40),\n... ]\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.dt.total_milliseconds()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    10\n1    20\ndtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i64]\n[\n        10\n        20\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.total_microseconds","title":"<code>total_microseconds()</code>","text":"<p>Get total microseconds.</p> Notes <p>The function outputs the total microseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [\n...     timedelta(microseconds=10),\n...     timedelta(milliseconds=1, microseconds=200),\n... ]\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.dt.total_microseconds()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0      10\n1    1200\ndtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i64]\n[\n        10\n        1200\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.total_nanoseconds","title":"<code>total_nanoseconds()</code>","text":"<p>Get total nanoseconds.</p> Notes <p>The function outputs the total nanoseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [\"2024-01-01 00:00:00.000000001\", \"2024-01-01 00:00:00.000000002\"]\n&gt;&gt;&gt; s_pd = pd.to_datetime(pd.Series(data))\n&gt;&gt;&gt; s_pl = pl.Series(data).str.to_datetime(time_unit=\"ns\")\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.diff().dt.total_nanoseconds()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    NaN\n1    1.0\ndtype: float64\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i64]\n[\n        null\n        1\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.to_string","title":"<code>to_string(format)</code>","text":"<p>Convert a Date/Time/Datetime series into a String series with the given format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [\n...     datetime(2020, 3, 1),\n...     datetime(2020, 4, 1),\n...     datetime(2020, 5, 1),\n... ]\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.dt.to_string(\"%Y/%m/%d\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    2020/03/01\n1    2020/04/01\n2    2020/05/01\ndtype: object\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [str]\n[\n   \"2020/03/01\"\n   \"2020/04/01\"\n   \"2020/05/01\"\n]\n</code></pre>"},{"location":"api-reference/series_str/","title":"<code>narwhals.Series.str</code>","text":""},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.contains","title":"<code>contains(pattern, *, literal=False)</code>","text":"<p>Check if string contains a substring that matches a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>A Character sequence or valid regular expression pattern.</p> required <code>literal</code> <code>bool</code> <p>If True, treats the pattern as a literal string.      If False, assumes the pattern is a regular expression.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; pets = [\"cat\", \"dog\", \"rabbit and parrot\", \"dove\", None]\n&gt;&gt;&gt; s_pd = pd.Series(pets)\n&gt;&gt;&gt; s_pl = pl.Series(pets)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.str.contains(\"parrot|dove\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    False\n1    False\n2     True\n3     True\n4     None\ndtype: object\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (5,)\nSeries: '' [bool]\n[\n   false\n   false\n   true\n   true\n   null\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.ends_with","title":"<code>ends_with(suffix)</code>","text":"<p>Check if string values end with a substring.</p> <p>Parameters:</p> Name Type Description Default <code>suffix</code> <code>str</code> <p>suffix substring</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [\"apple\", \"mango\", None]\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(series):\n...     return series.str.ends_with(\"ngo\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    False\n1     True\n2     None\ndtype: object\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [bool]\n[\n   false\n   true\n   null\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.head","title":"<code>head(n=5)</code>","text":"<p>Take the first n elements of each string.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to take. Negative indexing is supported (see note (1.))</p> <code>5</code> Notes <ol> <li>When the <code>n</code> input is negative, <code>head</code> returns characters up to the n-th from the end of the string.     For example, if <code>n = -3</code>, then all characters except the last three are returned.</li> <li>If the length of the string has fewer than <code>n</code> characters, the full string is returned.</li> </ol> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lyrics = [\"Atatata\", \"taata\", \"taatatata\", \"zukkyun\"]\n&gt;&gt;&gt; s_pd = pd.Series(lyrics)\n&gt;&gt;&gt; s_pl = pl.Series(lyrics)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.str.head()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    Atata\n1    taata\n2    taata\n3    zukky\ndtype: object\n&gt;&gt;&gt; func(s_pl)\nshape: (4,)\nSeries: '' [str]\n[\n   \"Atata\"\n   \"taata\"\n   \"taata\"\n   \"zukky\"\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.slice","title":"<code>slice(offset, length=None)</code>","text":"<p>Create subslices of the string values of a Series.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>Start index. Negative indexing is supported.</p> required <code>length</code> <code>int | None</code> <p>Length of the slice. If set to <code>None</code> (default), the slice is taken to the end of the string.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [\"pear\", None, \"papaya\", \"dragonfruit\"]\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.str.slice(4, length=3)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0\n1    None\n2      ya\n3     onf\ndtype: object\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (4,)\nSeries: '' [str]\n[\n   \"\"\n   null\n   \"ya\"\n   \"onf\"\n]\n</code></pre> <p>Using negative indexes:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.str.slice(-3)\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pd)\n0     ear\n1    None\n2     aya\n3     uit\ndtype: object\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (4,)\nSeries: '' [str]\n[\n    \"ear\"\n    null\n    \"aya\"\n    \"uit\"\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.starts_with","title":"<code>starts_with(prefix)</code>","text":"<p>Check if string values start with a substring.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>prefix substring</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [\"apple\", \"mango\", None]\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(series):\n...     return series.str.starts_with(\"app\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0     True\n1    False\n2     None\ndtype: object\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [bool]\n[\n   true\n   false\n   null\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.tail","title":"<code>tail(n=5)</code>","text":"<p>Take the last n elements of each string.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to take. Negative indexing is supported (see note (1.))</p> <code>5</code> Notes <ol> <li>When the <code>n</code> input is negative, <code>tail</code> returns characters starting from the n-th from the beginning of     the string. For example, if <code>n = -3</code>, then all characters except the first three are returned.</li> <li>If the length of the string has fewer than <code>n</code> characters, the full string is returned.</li> </ol> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lyrics = [\"Atatata\", \"taata\", \"taatatata\", \"zukkyun\"]\n&gt;&gt;&gt; s_pd = pd.Series(lyrics)\n&gt;&gt;&gt; s_pl = pl.Series(lyrics)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s_any):\n...     return s_any.str.tail()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    atata\n1    taata\n2    atata\n3    kkyun\ndtype: object\n&gt;&gt;&gt; func(s_pl)\nshape: (4,)\nSeries: '' [str]\n[\n   \"atata\"\n   \"taata\"\n   \"atata\"\n   \"kkyun\"\n]\n</code></pre>"},{"location":"basics/column/","title":"Series","text":"<p>In dataframe, you learned how to write a dataframe-agnostic function.</p> <p>We only used DataFrame methods there - but what if we need to operate on its columns?</p> <p>Note that Polars does not have lazy columns. If you need to operate on columns as part of a dataframe operation, you should use expressions - but if you need to extract a single column, you need to ensure that you start with an eager <code>DataFrame</code>. To do that, you need to pass <code>eager_only=True</code> to <code>nw.from_native</code>.</p>"},{"location":"basics/column/#example-1-filter-based-on-a-columns-values","title":"Example 1: filter based on a column's values","text":"<p>This can stay lazy, so we just use <code>nw.from_native</code> and expressions:</p> <pre><code>import narwhals as nw\n\n@nw.narwhalify\ndef my_func(df):\n    return df.filter(nw.col('a') &gt; 0)\n</code></pre> pandasPolars (eager)Polars (lazy) <pre><code>import pandas as pd\n\ndf = pd.DataFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>   a  b\n1  1  5\n2  3 -3\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>shape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 5   \u2502\n\u2502 3   \u2506 -3  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df).collect())\n</code></pre> <pre><code>shape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 5   \u2502\n\u2502 3   \u2506 -3  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"basics/column/#example-2-multiply-a-columns-values-by-a-constant","title":"Example 2: multiply a column's values by a constant","text":"<p>Let's write a dataframe-agnostic function which multiplies the values in column <code>'a'</code> by 2. This can also stay lazy, and can use expressions:</p> <pre><code>import narwhals as nw\n\n@nw.narwhalify\ndef my_func(df):\n    return df.with_columns(nw.col('a')*2)\n</code></pre> pandasPolars (eager)Polars (lazy) <pre><code>import pandas as pd\n\ndf = pd.DataFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>   a  b\n0 -2  3\n1  2  5\n2  6 -3\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>shape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 -2  \u2506 3   \u2502\n\u2502 2   \u2506 5   \u2502\n\u2502 6   \u2506 -3  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df).collect())\n</code></pre> <pre><code>shape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 -2  \u2506 3   \u2502\n\u2502 2   \u2506 5   \u2502\n\u2502 6   \u2506 -3  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Note that column <code>'a'</code> was overwritten. If we had wanted to add a new column called <code>'c'</code> containing column <code>'a'</code>'s values multiplied by 2, we could have used <code>Expr.alias</code>:</p> <pre><code>import narwhals as nw\n\n@nw.narwhalify\ndef my_func(df):\n    return df.with_columns((nw.col('a')*2).alias('c'))\n</code></pre> pandasPolars (eager)Polars (lazy) <pre><code>import pandas as pd\n\ndf = pd.DataFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>   a  b  c\n0 -1  3 -2\n1  1  5  2\n2  3 -3  6\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 -1  \u2506 3   \u2506 -2  \u2502\n\u2502 1   \u2506 5   \u2506 2   \u2502\n\u2502 3   \u2506 -3  \u2506 6   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df).collect())\n</code></pre> <pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 -1  \u2506 3   \u2506 -2  \u2502\n\u2502 1   \u2506 5   \u2506 2   \u2502\n\u2502 3   \u2506 -3  \u2506 6   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"basics/column/#example-3-finding-the-mean-of-a-column-as-a-scalar","title":"Example 3: finding the mean of a column as a scalar","text":"<p>Now, we want to find the mean of column <code>'a'</code>, and we need it as a Python scalar. This means that computation cannot stay lazy - it must execute! Therefore, we'll pass <code>eager_only=True</code> to <code>nw.from_native</code>, and then, instead of using expressions, we'll extract a <code>Series</code>.</p> <pre><code>import narwhals as nw\n\n@nw.narwhalify\ndef my_func(df_any):\n    return df_any['a'].mean()\n</code></pre> pandasPolars (eager) <pre><code>import pandas as pd\n\ndf = pd.DataFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>1.0\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>1.0\n</code></pre> <p>Note that, even though the output of our function is not a dataframe nor a series, we can still use <code>narwhalify</code>.</p> <p>In general, we recommend using the decorator where possible, as it looks a lot cleaner, and only using <code>nw.from_native</code> / <code>nw.to_native</code> explicitly when you need them.</p>"},{"location":"basics/complete_example/","title":"Complete example","text":"<p>We're going to write a dataframe-agnostic \"Standard Scaler\". This class will have <code>fit</code> and <code>transform</code> methods (like <code>scikit-learn</code> transformers), and will work agnostically for pandas and Polars.</p> <p>We'll need to write two methods:</p> <ul> <li><code>fit</code>: find the mean and standard deviation for each column from a given training set;</li> <li><code>transform</code>: scale a given dataset with the mean and standard deviations calculated   during <code>fit</code>.</li> </ul> <p>The <code>fit</code> method is a bit complicated, so let's start with <code>transform</code>. Suppose we've already calculated the mean and standard deviation of each column, and have stored them in attributes <code>self.means</code> and <code>self.std_devs</code>.</p>"},{"location":"basics/complete_example/#transform-method","title":"Transform method","text":"<p>We're going to take in a dataframe, and return a dataframe of the same type. Therefore, we use <code>@nw.narwhalify</code>:</p> <pre><code>import narwhals as nw\n\nclass StandardScaler:\n    @nw.narwhalify\n    def transform(self, df):\n        return df.with_columns(\n            (nw.col(col) - self._means[col]) / self._std_devs[col]\n            for col in df.columns\n        )\n</code></pre> <p>Note that all the calculations here can stay lazy if the underlying library permits it, so we don't pass in any extra keyword-arguments such as <code>eager_only</code>, we just use the default <code>eager_only=False</code>.</p>"},{"location":"basics/complete_example/#fit-method","title":"Fit method","text":"<p>Unlike the <code>transform</code> method, <code>fit</code> cannot stay lazy, as we need to compute concrete values for the means and standard deviations.</p> <p>To be able to get <code>Series</code> out of our <code>DataFrame</code>, we'll pass <code>eager_only=True</code> to <code>nw.from_native</code>. This is because Polars doesn't have a concept of lazy <code>Series</code>, and so Narwhals doesn't either.</p> <p>We can specify that in the <code>@nw.narwhalify</code> decorator by setting <code>eager_only=True</code>, and the argument will be propagated to <code>nw.from_native</code>.</p> <pre><code>import narwhals as nw\n\nclass StandardScaler:\n    @nw.narwhalify(eager_only=True)\n    def fit(self, df_any):\n        self._means = {col: df[col].mean() for col in df.columns}\n        self._std_devs = {col: df[col].std() for col in df.columns}\n</code></pre>"},{"location":"basics/complete_example/#putting-it-all-together","title":"Putting it all together","text":"<p>Here is our dataframe-agnostic standard scaler: <pre><code>import narwhals as nw\n\nclass StandardScaler:\n    @nw.narwhalify(eager_only=True)\n    def fit(self, df_any):\n        df = nw.from_native(df_any, eager_only=True)\n        self._means = {col: df[col].mean() for col in df.columns}\n        self._std_devs = {col: df[col].std() for col in df.columns}\n\n    @nw.narwhalify\n    def transform(self, df):\n        return df.with_columns(\n            (nw.col(col) - self._means[col]) / self._std_devs[col]\n            for col in df.columns\n        )\n</code></pre></p> <p>Next, let's try running it. Notice how, as <code>transform</code> doesn't use any eager-only features, so we can pass a Polars LazyFrame to it and have it stay lazy!</p> pandasPolars <pre><code>Traceback (most recent call last):\n  File \"/opt/hostedtoolcache/Python/3.12.4/x64/lib/python3.12/site-packages/markdown_exec/formatters/python.py\", line 71, in _run_python\n    exec_python(code, code_block_id, exec_globals)\n  File \"/opt/hostedtoolcache/Python/3.12.4/x64/lib/python3.12/site-packages/markdown_exec/formatters/_exec_python.py\", line 8, in exec_python\n    exec(compiled, exec_globals)  # noqa: S102\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"&lt;code block: session tute-ex1; n2&gt;\", line 6, in &lt;module&gt;\n    scaler.fit(df_train)\n  File \"/home/runner/work/narwhals/narwhals/narwhals/translate.py\", line 335, in wrapper\n    result = func(*args, **kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"&lt;code block: session tute-ex1; n1&gt;\", line 6, in fit\n    df = nw.from_native(df_any, eager_only=True)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/runner/work/narwhals/narwhals/narwhals/translate.py\", line 217, in from_native\n    raise TypeError(msg)\nTypeError: Expected pandas-like dataframe, Polars dataframe, or Polars lazyframe, got: &lt;class 'narwhals.dataframe.DataFrame'&gt;\n</code></pre> <pre><code>Traceback (most recent call last):\n  File \"/opt/hostedtoolcache/Python/3.12.4/x64/lib/python3.12/site-packages/markdown_exec/formatters/python.py\", line 71, in _run_python\n    exec_python(code, code_block_id, exec_globals)\n  File \"/opt/hostedtoolcache/Python/3.12.4/x64/lib/python3.12/site-packages/markdown_exec/formatters/_exec_python.py\", line 8, in exec_python\n    exec(compiled, exec_globals)  # noqa: S102\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"&lt;code block: session tute-ex1; n3&gt;\", line 6, in &lt;module&gt;\n    scaler.fit(df_train)\n  File \"/home/runner/work/narwhals/narwhals/narwhals/translate.py\", line 335, in wrapper\n    result = func(*args, **kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"&lt;code block: session tute-ex1; n1&gt;\", line 6, in fit\n    df = nw.from_native(df_any, eager_only=True)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/runner/work/narwhals/narwhals/narwhals/translate.py\", line 217, in from_native\n    raise TypeError(msg)\nTypeError: Expected pandas-like dataframe, Polars dataframe, or Polars lazyframe, got: &lt;class 'narwhals.dataframe.DataFrame'&gt;\n</code></pre>"},{"location":"basics/dataframe/","title":"DataFrame","text":"<p>To write a dataframe-agnostic function, the steps you'll want to follow are:</p> <ol> <li> <p>Initialise a Narwhals DataFrame or LazyFrame by passing your dataframe to <code>nw.from_native</code>.     All the calculations stay lazy if we start with a lazy dataframe - Narwhals will never automatically trigger computation without you asking it to.</p> <p>Note: if you need eager execution, make sure to pass <code>eager_only=True</code> to <code>nw.from_native</code>.</p> </li> <li> <p>Express your logic using the subset of the Polars API supported by Narwhals.</p> </li> <li>If you need to return a dataframe to the user in its original library, call <code>nw.to_native</code>.</li> </ol> <p>Steps 1 and 3 are so common that we provide a utility <code>@nw.narwhalify</code> decorator, which allows you to only explicitly write step 2.</p> <p>Let's explore this with some simple examples.</p>"},{"location":"basics/dataframe/#example-1-descriptive-statistics","title":"Example 1: descriptive statistics","text":"<p>Just like in Polars, we can pass expressions to <code>DataFrame.select</code> or <code>LazyFrame.select</code>.</p> <p>Make a Python file with the following content: <pre><code>import narwhals as nw\n\n@nw.narwhalify\ndef func(df):\n    return df.select(\n        a_sum=nw.col('a').sum(),\n        a_mean=nw.col('a').mean(),\n        a_std=nw.col('a').std(),\n    )\n</code></pre> Let's try it out:</p> pandasPolars (eager)Polars (lazy) <pre><code>import pandas as pd\n\ndf = pd.DataFrame({'a': [1, 1, 2]})\nprint(func(df))\n</code></pre> <pre><code>   a_sum    a_mean    a_std\n0      4  1.333333  0.57735\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({'a': [1, 1, 2]})\nprint(func(df))\n</code></pre> <pre><code>shape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a_sum \u2506 a_mean   \u2506 a_std   \u2502\n\u2502 ---   \u2506 ---      \u2506 ---     \u2502\n\u2502 i64   \u2506 f64      \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 4     \u2506 1.333333 \u2506 0.57735 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({'a': [1, 1, 2]})\nprint(func(df).collect())\n</code></pre> <pre><code>shape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a_sum \u2506 a_mean   \u2506 a_std   \u2502\n\u2502 ---   \u2506 ---      \u2506 ---     \u2502\n\u2502 i64   \u2506 f64      \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 4     \u2506 1.333333 \u2506 0.57735 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Alternatively, we could have opted for the more explicit version: <pre><code>import narwhals as nw\n\ndef func(df_any):\n    df = nw.from_native(df_any)\n    df = df.select(\n        a_sum=nw.col('a').sum(),\n        a_mean=nw.col('a').mean(),\n        a_std=nw.col('a').std(),\n    )\n    return nw.to_native(df)\n</code></pre></p> <p>In general, we think <code>@nw.narwhalify</code> is more legible, so we'll use that wherever possible.</p>"},{"location":"basics/dataframe/#example-2-group-by-and-mean","title":"Example 2: group-by and mean","text":"<p>Just like in Polars, we can pass expressions to <code>GroupBy.agg</code>. Make a Python file with the following content: <pre><code>import narwhals as nw\n\n@nw.narwhalify\ndef func(df):\n    return df.group_by('a').agg(nw.col('b').mean()).sort('a')\n</code></pre> Let's try it out:</p> pandasPolars (eager)Polars (lazy) <pre><code>import pandas as pd\n\ndf = pd.DataFrame({'a': [1, 1, 2], 'b': [4, 5, 6]})\nprint(func(df))\n</code></pre> <pre><code>   a    b\n0  1  4.5\n1  2  6.0\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({'a': [1, 1, 2], 'b': [4, 5, 6]})\nprint(func(df))\n</code></pre> <pre><code>shape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 4.5 \u2502\n\u2502 2   \u2506 6.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({'a': [1, 1, 2], 'b': [4, 5, 6]})\nprint(func(df).collect())\n</code></pre> <pre><code>shape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 4.5 \u2502\n\u2502 2   \u2506 6.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"basics/dataframe/#example-3-horizontal-sum","title":"Example 3: horizontal sum","text":"<p>Expressions can be free-standing functions which accept other expressions as inputs. For example, we can compute a horizontal sum using <code>nw.sum_horizontal</code>.</p> <p>Make a Python file with the following content: <pre><code>import narwhals as nw\n\n@nw.narwhalify\ndef func(df):\n    return df.with_columns(a_plus_b=nw.sum_horizontal('a', 'b'))\n</code></pre> Let's try it out:</p> pandasPolars (eager)Polars (lazy) <pre><code>import pandas as pd\n\ndf = pd.DataFrame({'a': [1, 1, 2], 'b': [4, 5, 6]})\nprint(func(df))\n</code></pre> <pre><code>   a  b  a_plus_b\n0  1  4         5\n1  1  5         6\n2  2  6         8\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({'a': [1, 1, 2], 'b': [4, 5, 6]})\nprint(func(df))\n</code></pre> <pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 a_plus_b \u2502\n\u2502 --- \u2506 --- \u2506 ---      \u2502\n\u2502 i64 \u2506 i64 \u2506 i64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 4   \u2506 5        \u2502\n\u2502 1   \u2506 5   \u2506 6        \u2502\n\u2502 2   \u2506 6   \u2506 8        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({'a': [1, 1, 2], 'b': [4, 5, 6]})\nprint(func(df).collect())\n</code></pre> <pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 a_plus_b \u2502\n\u2502 --- \u2506 --- \u2506 ---      \u2502\n\u2502 i64 \u2506 i64 \u2506 i64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 4   \u2506 5        \u2502\n\u2502 1   \u2506 5   \u2506 6        \u2502\n\u2502 2   \u2506 6   \u2506 8        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"basics/dataframe/#example-4-multiple-inputs","title":"Example 4: multiple inputs","text":"<p><code>nw.narwhalify</code> can be used to decorate functions that take multiple inputs as well and return a non dataframe/series-like object.</p> <p>For example, let's compute how many rows are left in a dataframe after filtering it based on a series.</p> <p>Make a Python file with the following content: <pre><code>import narwhals as nw\n\n@nw.narwhalify(eager_only=True)\ndef func(df: nw.DataFrame, s: nw.Series, col_name: str):\n    return df.filter(nw.col(col_name).is_in(s)).shape[0]\n</code></pre></p> <p>We require <code>eager_only=True</code> here because lazyframe doesn't support <code>.shape</code>.</p> <p>Let's try it out:</p> pandasPolars (eager) <pre><code>import pandas as pd\n\ndf = pd.DataFrame({'a': [1, 1, 2, 2, 3], 'b': [4, 5, 6, 7, 8]})\ns = pd.Series([1, 3])\nprint(func(df, s.to_numpy(), 'a'))\n</code></pre> <pre><code>3\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({'a': [1, 1, 2, 2, 3], 'b': [4, 5, 6, 7, 8]})\ns = pl.Series([1, 3])\nprint(func(df, s.to_numpy(), 'a'))\n</code></pre> <pre><code>3\n</code></pre>"},{"location":"other/pandas_index/","title":"What about the pandas Index?","text":"<p>There are two types of pandas users:</p> <ul> <li>The ones who make full use of the Index's power.</li> <li>The <code>.reset_index(drop=True)</code> ones, who would rather not think about the Index.</li> </ul> <p>Narwhals aims to accommodate both!</p> <ul> <li>If you'd rather not think about the Index, then don't   worry: it's not part of the Narwhals public API, and you'll never have to worry about   resetting the index or about pandas doing funky index alignment for you.</li> <li>If you want your library to cater to Index powerusers who would be very angry if you reset   their beautiful Index on their behalf, then don't worry: Narwhals makes certain promises   with regards to the Index.</li> </ul> <p>Let's learn about what Narwhals promises.</p>"},{"location":"other/pandas_index/#1-narwhals-will-preserve-your-index-for-dataframe-operations","title":"1. Narwhals will preserve your index for dataframe operations","text":"<pre><code>import narwhals as nw\n\ndef my_func(df_any):\n    df = nw.from_native(df_any)\n    df = df.with_columns(a_plus_one=nw.col('a')+1)\n    return nw.to_native(df)\n</code></pre> <p>Let's start with a dataframe with an Index with values <code>[7, 8, 9]</code>.</p> <pre><code>import pandas as pd\n\ndf = pd.DataFrame({'a': [2, 1, 3], 'b': [3, 5, -3]}, index=[7, 8, 9])\nprint(my_func(df))\n</code></pre> <pre><code>   a  b  a_plus_one\n7  2  3           3\n8  1  5           2\n9  3 -3           4\n</code></pre> <p>Note how the result still has the original index - Narwhals did not modify it.</p>"},{"location":"other/pandas_index/#2-index-alignment-follows-the-left-hand-rule","title":"2. Index alignment follows the left-hand-rule","text":"<p>pandas automatically aligns indices for users. For example:</p> <p><pre><code>import pandas as pd\n\ndf_pd = pd.DataFrame({'a': [2, 1, 3], 'b': [4, 5, 6]})\ns_pd = df_pd['a'].sort_values()\ndf_pd['a_sorted'] = s_pd\n</code></pre> Reading the code, you might expect that <code>'a_sorted'</code> will contain the values <code>[1, 2, 3]</code>.</p> <p>However, here's what actually happens: <pre><code>print(df_pd)\n</code></pre> <pre><code>   a  b  a_sorted\n0  2  4         2\n1  1  5         1\n2  3  6         3\n</code></pre>  In other words, pandas' index alignment undid the <code>sort_values</code> operation!</p> <p>Narwhals, on the other hand, preserves the index of the left-hand-side argument. Everything else will be inserted positionally, just like Polars would do:</p> <pre><code>import narwhals as nw\n\ndf = nw.from_native(df_pd)\ns = nw.from_native(s_pd, allow_series=True)\ndf = df.with_columns(a_sorted=s.sort())\nprint(nw.to_native(df))\n</code></pre> <pre><code>   a  b  a_sorted\n0  2  4         1\n1  1  5         2\n2  3  6         3\n</code></pre> <p>If you keep these two rules in mind, then Narwhals will both help you avoid Index-related surprises whilst letting you preserve the Index for the subset of your users who consciously make great use of it.</p>"}]}